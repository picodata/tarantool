/**
 * Copyright (C) Picodata LLC - All Rights Reserved
 *
 * This source code is protected under international copyright law.  All rights
 * reserved and protected by the copyright holders.
 * This file is confidential and only available to authorized individuals with
 * the permission of the copyright holders.  If you encounter this file and do
 * not have permission, please contact the copyright holders and delete this
 * file.
 */

#include "sqlInt.h"
#include "vdbe.h"
#include "vdbeInt.h"
#include "box/sql.h"
#include "box/field_def.h"

/*
 * SELECT REWRITING
 *
 * Any SELECT statement that contains one or more window functions in
 * either the select list or ORDER BY clause (the only two places window
 * functions may be used) is transformed by function sqlWindowRewrite()
 * in order to support window function processing. For example, with the
 * schema:
 *
 *   CREATE TABLE t1(a, b, c, d, e, f, g);
 *
 * the statement:
 *
 *   SELECT a+1, max(b) OVER (PARTITION BY c ORDER BY d) FROM t1 ORDER BY e;
 *
 * is transformed to:
 *
 *   SELECT a+1, max(b) OVER (PARTITION BY c ORDER BY d) FROM (
 *       SELECT a, e, c, d, b FROM t1 ORDER BY c, d
 *   ) ORDER BY e;
 *
 * The flattening optimization is disabled when processing this transformed
 * SELECT statement. This allows the implementation of the window function
 * (in this case max()) to process rows sorted in order of (c, d), which
 * makes things easier for obvious reasons. More generally:
 *
 *   * FROM, WHERE, GROUP BY and HAVING clauses are all moved to
 *     the sub-query.
 *
 *   * ORDER BY, LIMIT and OFFSET remain part of the parent query.
 *
 *   * Terminals from each of the expression trees that make up the
 *     select-list and ORDER BY expressions in the parent query are
 *     selected by the sub-query. For the purposes of the transformation,
 *     terminals are column references and aggregate functions.
 *
 * If there is more than one window function in the SELECT that uses
 * the same window declaration (the OVER bit), then a single scan may
 * be used to process more than one window function. For example:
 *
 *   SELECT max(b) OVER (PARTITION BY c ORDER BY d),
 *          min(e) OVER (PARTITION BY c ORDER BY d)
 *   FROM t1;
 *
 * is transformed in the same way as the example above. However:
 *
 *   SELECT max(b) OVER (PARTITION BY c ORDER BY d),
 *          min(e) OVER (PARTITION BY a ORDER BY b)
 *   FROM t1;
 *
 * Must be transformed to:
 *
 *   SELECT max(b) OVER (PARTITION BY c ORDER BY d) FROM (
 *       SELECT e, min(e) OVER (PARTITION BY a ORDER BY b), c, d, b FROM
 *         SELECT a, e, c, d, b FROM t1 ORDER BY a, b
 *       ) ORDER BY c, d
 *   ) ORDER BY e;
 *
 * so that both min() and max() may process rows in the order defined by
 * their respective window declarations.
 *
 * INTERFACE WITH SELECT.C
 *
 * When processing the rewritten SELECT statement, code in select.c calls
 * sqlWhereBegin() to begin iterating through the results of the
 * sub-query, which is always implemented as a co-routine. It then calls
 * sqlWindowCodeStep() to process rows and finish the scan by calling
 * sqlWhereEnd().
 *
 * sqlWindowCodeStep() generates VM code so that, for each row returned
 * by the sub-query a sub-routine (OP_Gosub) coded by select.c is invoked.
 * When the sub-routine is invoked:
 *
 *   * The results of all window-functions for the row are stored
 *     in the associated Window.regResult registers.
 *
 *   * The required terminal values are stored in the current row of
 *     temp table Window.iEphCsr.
 *
 * In some cases, depending on the window frame and the specific window
 * functions invoked, sqlWindowCodeStep() caches each entire partition
 * in a temp table before returning any rows. In other cases it does not.
 * This detail is encapsulated within this file, the code generated by
 * select.c is the same in either case.
 *
 * BUILT-IN WINDOW FUNCTIONS
 *
 * This implementation features the following built-in window functions:
 *
 *   row_number()
 *
 * Not implemented:
 *   rank()
 *   dense_rank()
 *   percent_rank()
 *   cume_dist()
 *   ntile(N)
 *   lead(expr [, offset [, default]])
 *   lag(expr [, offset [, default]])
 *   first_value(expr)
 *   last_value(expr)
 *   nth_value(expr, N)
 *
 * These are the same built-in window functions supported by Postgres.
 * Although the behaviour of aggregate window functions (functions that
 * can be used as either aggregates or window functions) allows them to
 * be implemented using an API, built-in window functions are much more
 * esoteric. Additionally, some window functions (e.g. nth_value())
 * may only be implemented by caching the entire partition in memory.
 * As such, some built-in window functions use the same API as aggregate
 * window functions and some are implemented directly using VDBE
 * instructions. Additionally, for those functions that use the API, the
 * window frame is sometimes modified before the SELECT statement is
 * rewritten. For example, regardless of the specified window frame, the
 * row_number() function always uses:
 *
 *   ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
 *
 * See sqlWindowUpdate() for details.
 *
 * As well as some of the built-in window functions, aggregate window
 * functions min() and max() are implemented using VDBE instructions if
 * the start of the window frame is declared as anything other than
 * UNBOUNDED PRECEDING.
 */

static Window *
windowFind(Parse *pParse, Window *pList, const char *zName)
{
	Window *p;
	for (p = pList; p; p = p->pNextWin) {
		if (sqlStrICmp(p->zName, zName) == 0)
			break;
	}
	if (p == 0) {
		const char *err_msg = tt_sprintf("no such window: %s",
						 zName);
		diag_set(ClientError, ER_SQL_PARSER_GENERIC, err_msg);
		pParse->is_aborted = true;
	}
	return p;
}

/*
 * This function is called immediately after resolving the function name
 * for a window function within a SELECT statement. Argument pList is a
 * linked list of WINDOW definitions for the current SELECT statement.
 * Argument pFunc is the function definition just resolved and pWin
 * is the Window object representing the associated OVER clause. This
 * function updates the contents of pWin as follows:
 *
 *   * If the OVER clause referred to a named window (as in "max(x) OVER win"),
 *     search list pList for a matching WINDOW definition, and update pWin
 *     accordingly. If no such WINDOW clause can be found, leave an error
 *     in pParse.
 *
 *   * If the function is a built-in window function that requires the
 *     window to be coerced (see "BUILT-IN WINDOW FUNCTIONS" at the top
 *     of this file), pWin is updated here.
 */
void
sqlWindowUpdate(
	Parse *pParse,
	Window *pList,		/* List of named windows for this SELECT */
	Window *pWin,		/* Window frame to update */
	struct func *pFunc)	/* Window function definition */
{
	if (pWin->zName && pWin->eType == 0) {
		Window *p = windowFind(pParse, pList, pWin->zName);
		if (p == 0)
			return;
		pWin->pPartition = sql_expr_list_dup(p->pPartition, 0);
		pWin->pOrderBy = sql_expr_list_dup(p->pOrderBy, 0);
		pWin->pStart = sqlExprDup(p->pStart, 0);
		pWin->pEnd = sqlExprDup(p->pEnd, 0);
		pWin->eStart = p->eStart;
		pWin->eEnd = p->eEnd;
		pWin->eType = p->eType;
	} else {
		sqlWindowChain(pParse, pWin, pList);
	}
	uint32_t flags = sql_func_flags(pFunc->def->name);
	if ((flags & SQL_FUNC_WINDOW) != 0) {
		if (pWin->pFilter) {
			const char *err_msg;
			err_msg = tt_sprintf("%s %s",
					     "FILTER clause may only be used",
					     "with aggregate window functions");
			diag_set(ClientError, ER_SQL_PARSER_GENERIC, err_msg);
			pParse->is_aborted = true;
		} else {
			struct WindowUpdate {
				const char *zFunc;
				int eType;
				int eStart;
				int eEnd;
			} aUp[] = {
				{ "ROW_NUMBER",   TK_ROWS,   TK_UNBOUNDED, TK_CURRENT },
				/* NOTE(gmoshkin) the rest is commented out because we don't support those yet */
				/* { "DENSE_RANK",   TK_RANGE,  TK_UNBOUNDED, TK_CURRENT }, */
				/* { "RANK",         TK_RANGE,  TK_UNBOUNDED, TK_CURRENT }, */
				/* { "PERCENT_RANK", TK_GROUPS, TK_CURRENT,   TK_UNBOUNDED }, */
				/* { "CUME_DIST",    TK_GROUPS, TK_FOLLOWING, TK_UNBOUNDED }, */
				/* { "NTILE",        TK_ROWS,   TK_CURRENT,   TK_UNBOUNDED }, */
				/* { "LEAD",         TK_ROWS,   TK_UNBOUNDED, TK_UNBOUNDED }, */
			};
			int i;
			for(i=0; i<ArraySize(aUp); i++){
				/* NOTE(gmoshkin) sqlite doesn't use strcmp here, instead they compare
				 * the string pointers against the named constants, because they
				 * deduplicate the tokens in the parser. Tarantool doesn't seem to do
				 * this, so the best thing I can think of is to use strcmp...
				 */
				if( strcmp(pFunc->def->name, aUp[i].zFunc) == 0 ){
					sql_expr_delete(pWin->pStart);
					sql_expr_delete(pWin->pEnd);
					pWin->pEnd = pWin->pStart = 0;
					pWin->eType = aUp[i].eType;
					pWin->eStart = aUp[i].eStart;
					pWin->eEnd = aUp[i].eEnd;
					if( pWin->eStart==TK_FOLLOWING ){
						Token t;
						sqlTokenInit(&t, "1");
						pWin->pStart = sql_expr_new(TK_INTEGER, &t);
					}
					break;
				}
			}
		}
	}
	pWin->pFunc = pFunc;
}

/*
 * Context object passed through sqlWalkExprList() to
 * selectWindowRewriteExprCb() by selectWindowRewriteEList().
 */
struct WindowRewrite {
	/* Windows for this traversal */
	Window *pWin;
	SrcList *pSrc;
	/* Rewritten expression list */
	ExprList *pSub;
	/* Current sub-select, if any */
	Select *pSubSelect;
};

/*
 * Callback function used by selectWindowRewriteEList(). If necessary,
 * this function appends to the output expression-list and updates
 * expression (*ppExpr) in place.
 */
static int
selectWindowRewriteExprCb(Walker *pWalker, Expr *pExpr)
{
	struct WindowRewrite *p = pWalker->u.pRewrite;

	/* If this function is being called from within a scalar sub-select
	** that used by the SELECT statement being processed, only process
	** TK_COLUMN_REF expressions that refer to it (the outer SELECT). Do
	** not process aggregates or window functions at all, as they belong
	** to the scalar sub-select.  */
	if (p->pSubSelect) {
		if (pExpr->op != TK_COLUMN_REF) {
			return WRC_Continue;
		} else {
			int nSrc = p->pSrc->nSrc;
			int i;
			for (i = 0; i < nSrc; i++) {
				if (pExpr->iTable == p->pSrc->a[i].iCursor)
					break;
			}
			if (i == nSrc)
				return WRC_Continue;
		}
	}

	enum field_type eType = sql_expr_type(pExpr);
	ExprClearProperty(pExpr, EP_Resolved);

	switch (pExpr->op) {
	case TK_FUNCTION:
		if (!ExprHasProperty(pExpr, EP_WinFunc)) {
			break;
		}
		Window *pWin;
		for (pWin = p->pWin; pWin; pWin = pWin->pNextWin) {
			if (pExpr->y.pWin == pWin) {
				assert(pWin->pOwner == pExpr);
				return WRC_Prune;
			}
		}
	FALLTHROUGH;
	case TK_AGG_FUNCTION:
	case TK_COLUMN_REF: {
		Expr *pDup = sqlExprDup(pExpr, 0);
		p->pSub = sql_expr_list_append(p->pSub, pDup);
		if (p->pSub) {
			assert(ExprHasProperty(pExpr, EP_Static) == 0);
			ExprSetProperty(pExpr, EP_Static);
			sql_expr_delete(pExpr);
			ExprClearProperty(pExpr, EP_Static);
			memset(pExpr, 0, sizeof(Expr));

			pExpr->op = TK_WIN_COLUMN;
			pExpr->type = eType;
			pExpr->iColumn = p->pSub->nExpr - 1;
			pExpr->iTable = p->pWin->iEphCsr;
		}

		break;
	}
	default: /* no-op */
		break;
	}
	return WRC_Continue;
}

static int
selectWindowRewriteSelectCb(Walker *pWalker, Select *pSelect)
{
	struct WindowRewrite *p = pWalker->u.pRewrite;
	Select *pSave = p->pSubSelect;
	if (pSave == pSelect) {
		return WRC_Continue;
	} else {
		p->pSubSelect = pSelect;
		sqlWalkSelect(pWalker, pSelect);
		p->pSubSelect = pSave;
	}
	return WRC_Prune;
}

/*
 * Iterate through each expression in expression-list pEList. For each:
 *
 *   * TK_COLUMN_REF,
 *   * aggregate function, or
 *   * window function with a Window object that is not a member of the
 *     Window list passed as the second argument (pWin)
 *
 * Append the node to output expression-list (*ppSub). And replace it
 * with a TK_COLUMN_REF that reads the (N-1)th element of table
 * pWin->iEphCsr, where N is the number of elements in (*ppSub) after
 * appending the new one.
 */
static void
selectWindowRewriteEList(
	Parse *pParse,
	Window *pWin,
	SrcList *pSrc,
	ExprList *pEList,	/* Rewrite expressions in this list */
	ExprList **ppSub)	/* IN/OUT: Sub-select expression-list */
{
	Walker sWalker;
	struct WindowRewrite sRewrite;

	memset(&sWalker, 0, sizeof(Walker));
	memset(&sRewrite, 0, sizeof(struct WindowRewrite));

	sRewrite.pSub = *ppSub;
	sRewrite.pWin = pWin;
	sRewrite.pSrc = pSrc;

	sWalker.pParse = pParse;
	sWalker.xExprCallback = selectWindowRewriteExprCb;
	sWalker.xSelectCallback = selectWindowRewriteSelectCb;
	sWalker.u.pRewrite = &sRewrite;

	(void)sqlWalkExprList(&sWalker, pEList);

	*ppSub = sRewrite.pSub;
}

/*
 * Append a copy of each expression in expression-list pAppend to
 * expression list pList. Return a pointer to the result list.
 */
static ExprList *
exprListAppendList(
	ExprList *pList,	/* List to which to append. Might be NULL */
	ExprList *pAppend)	/* List of values to append. Might be NULL */
{
	if (pAppend) {
		int i;
		int nInit = pList ? pList->nExpr : 0;
		for (i = 0; i < pAppend->nExpr; i++) {
			Expr *pDup = sqlExprDup(pAppend->a[i].pExpr, 0);
			pList = sql_expr_list_append(pList, pDup);
			if (pList)
				pList->a[nInit + i].sort_order =
				pAppend->a[i].sort_order;
		}
	}
	return pList;
}

/*
 * If the SELECT statement passed as the second argument does not invoke
 * any SQL window functions, this function is a no-op. Otherwise, it
 * rewrites the SELECT statement so that window function xStep functions
 * are invoked in the correct order as described under "SELECT REWRITING"
 * at the top of this file.
 */
int
sqlWindowRewrite(Parse *pParse, Select *p)
{
	int rc = 0;
	if (p->pWin && p->pPrior == 0) {
		Vdbe *v = sqlGetVdbe(pParse);
		/* The subquery */
		Select *pSub = 0;
		SrcList *pSrc = p->pSrc;
		Expr *pWhere = p->pWhere;
		ExprList *pGroupBy = p->pGroupBy;
		Expr *pHaving = p->pHaving;
		ExprList *pSort = 0;

		/* Expression list for sub-query */
		ExprList *pSublist = 0;
		/* Master window object */
		Window *pMWin = p->pWin;
		/* Window object iterator */
		Window *pWin;

		p->pSrc = 0;
		p->pWhere = 0;
		p->pGroupBy = 0;
		p->pHaving = 0;

		/*
		 * Create the ORDER BY clause for the sub-select.
		 * This is the concatenation
		 * of the window PARTITION and ORDER BY clauses.
		 * Then, if this makes it redundant,
		 * remove the ORDER BY from the parent SELECT.
		 */
		pSort = sql_expr_list_dup(pMWin->pPartition, 0);
		pSort = exprListAppendList(pSort, pMWin->pOrderBy);
		if (pSort && p->pOrderBy) {
			if (sqlExprListCompare(pSort, p->pOrderBy, -1) == 0) {
				sql_expr_list_delete(p->pOrderBy);
				p->pOrderBy = 0;
			}
		}

		/*
		 * Assign a cursor number
		 * for the ephemeral table used to buffer rows.
		 * The OpenTEphemeral instruction is coded later,
		 * after it is known how many columns the table will have.
		 */
		pMWin->iEphCsr = pParse->nTab++;
		pMWin->regEph = ++pParse->nMem;
		pParse->nTab += 3;

		selectWindowRewriteEList(pParse, pMWin, pSrc,
					 p->pEList, &pSublist);
		selectWindowRewriteEList(pParse, pMWin, pSrc,
					 p->pOrderBy, &pSublist);
		pMWin->nBufferCol = (pSublist ? pSublist->nExpr : 0);

		/*
		 * Append the PARTITION BY and ORDER BY expressions to the
		 * sub-select expression list.
		 * They are required to figure out where
		 * boundaries for partitions and sets of peer rows lie.
		 */
		pSublist = exprListAppendList(pSublist, pMWin->pPartition);
		pSublist = exprListAppendList(pSublist, pMWin->pOrderBy);

		/*
		 * Append the arguments passed to each window function to the
		 * sub-select expression list.
		 * Also allocate two registers for each
		 * window function - one for the accumulator,
		 * another for interim results.
		 */
		for (pWin = pMWin; pWin; pWin = pWin->pNextWin) {
			pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);
			pSublist = exprListAppendList(pSublist,
						      pWin->pOwner->x.pList);
			if (pWin->pFilter) {
				Expr *pFilter = sqlExprDup(pWin->pFilter, 0);
				pSublist = sql_expr_list_append(pSublist,
								pFilter);
			}
			pWin->regAccum = ++pParse->nMem;
			pWin->regResult = ++pParse->nMem;
			sqlVdbeAddOp2(v, OP_Null, 0, pWin->regAccum);
		}

		/* If there is no ORDER BY or PARTITION BY clause,
		 * and the window function accepts zero arguments,
		 * and there are no other columns selected
		 * (e.g. "SELECT row_number() OVER () FROM t1"), it is possible
		 * that pSublist is still NULL here.
		 * Add a constant expression here to
		 * keep everything legal in this case.
		 */
		if (pSublist == 0) {
			Token t;
			sqlTokenInit(&t, "0");
			pSublist = sql_expr_list_append(
					0,
					sql_expr_new(TK_INTEGER, &t));
		}

		pSub = sqlSelectNew(pParse, pSublist, pSrc, pWhere, pGroupBy,
				    pHaving, pSort, 0, 0, 0);
		p->pSrc = sql_src_list_append(0, 0);
		p->pSrc->a[0].pSelect = pSub;
		sqlSrcListAssignCursors(pParse, p->pSrc);
		sqlExpandSubquery(pParse, &p->pSrc->a[0]);
		pSub->selFlags |= SF_Expanded;
		p->selFlags &= ~SF_Aggregate;
		sqlSelectPrep(pParse, pSub, 0);

		/*
		 * Ephemeral table requires PK, so append a rowid to the end
		 * of the list.
		 * Rowid acts as a primary key for the ephemeral table.
		 */
		struct sql_space_info *info;
		info = sql_space_info_new_from_expr_list(pParse, pSublist,
							 true);
		info->part_count = 1;
		info->sort_orders[0] = SORT_ORDER_ASC;
		info->parts[0] = pSublist->nExpr;

		sqlVdbeAddOp4(v, OP_OpenTEphemeral, pMWin->regEph,
			      0, 0, (char *)info, P4_DYNAMIC);
		sqlVdbeAddOp3(v, OP_IteratorOpen, pMWin->iEphCsr,
			      0, pMWin->regEph);
		sqlVdbeAddOp3(v, OP_IteratorOpen, pMWin->iEphCsr + 1,
			      0, pMWin->regEph);
		sqlVdbeChangeP5(v, OPFLAG_EPH_DUP);
		sqlVdbeAddOp3(v, OP_IteratorOpen, pMWin->iEphCsr + 2,
			      0, pMWin->regEph);
		sqlVdbeChangeP5(v, OPFLAG_EPH_DUP);
		sqlVdbeAddOp3(v, OP_IteratorOpen, pMWin->iEphCsr + 3,
			      0, pMWin->regEph);
		sqlVdbeChangeP5(v, OPFLAG_EPH_DUP);
	}

	return rc;
}

/*
 * Free the Window object passed as the second argument.
 */
void
sqlWindowDelete(Window *p)
{
	if (p) {
		sql_expr_delete(p->pFilter);
		sql_expr_list_delete(p->pPartition);
		sql_expr_list_delete(p->pOrderBy);
		sql_expr_delete(p->pEnd);
		sql_expr_delete(p->pStart);
		sql_xfree(p->zName);
		sql_xfree(p->zBase);
		sql_xfree(p);
	}
}

/*
 * Free the linked list of Window objects starting at the second argument.
 */
void
sqlWindowListDelete(Window *p)
{
	while (p) {
		Window *pNext = p->pNextWin;
		sqlWindowDelete(p);
		p = pNext;
	}
}

/*
 * The argument expression is an PRECEDING or FOLLOWING offset.  The
 * value should be a non-negative integer.  If the value is not a
 * constant, change it to NULL.  The fact that it is then a non-negative
 * integer will be caught later.  But it is important not to leave
 * variable values in the expression tree.
 */
static Expr *
sqlWindowOffsetExpr(Expr *pExpr)
{
	if (sqlExprIsConstant(pExpr) == 0) {
		sql_expr_delete(pExpr);
		pExpr = sql_expr_new(TK_NULL, NULL);
	}
	return pExpr;
}

/*
 * Allocate and return a new Window object.
 */
Window *
sqlWindowAlloc(
	Parse *pParse, int eType,
	int eStart, Expr *pStart,
	int eEnd, Expr *pEnd)
{
	int bImplicitFrame = 0;

	/* Parser assures the following: */
	assert(eType == 0 || eType == TK_RANGE || eType == TK_ROWS);
	assert(eStart == TK_CURRENT || eStart == TK_PRECEDING ||
	       eStart == TK_UNBOUNDED || eStart == TK_FOLLOWING);
	assert(eEnd == TK_CURRENT || eEnd == TK_FOLLOWING ||
	       eEnd == TK_UNBOUNDED || eEnd == TK_PRECEDING);
	assert((eStart == TK_PRECEDING || eStart == TK_FOLLOWING)
	       == (pStart != 0));
	assert((eEnd == TK_FOLLOWING || eEnd == TK_PRECEDING)
	       == (pEnd != 0));

	if (eType == 0) {
		bImplicitFrame = 1;
		eType = TK_RANGE;
	}

	if (eType == TK_RANGE && (pStart != 0 || pEnd != 0)) {
		diag_set(ClientError, ER_SQL_PARSER_GENERIC,
			 "RANGE must use only UNBOUNDED or CURRENT ROW");
		pParse->is_aborted = true;
		return NULL;
	}

	/* Additionally, the starting boundary type may not occur earlier
	 * in the following list than the ending boundary type:
	 *
	 *   UNBOUNDED PRECEDING
	 *   <expr> PRECEDING
	 *   CURRENT ROW
	 *   <expr> FOLLOWING
	 *   UNBOUNDED FOLLOWING
	 *
	 * The parser ensures that "UNBOUNDED PRECEDING" cannot be used as an
	 * ending boundary, and than "UNBOUNDED FOLLOWING" cannot be used as
	 * a starting frame boundary.
	 */
	if ((eType == TK_RANGE && (pStart || pEnd)) ||
	    (eStart == TK_CURRENT && eEnd == TK_PRECEDING) ||
	    (eStart == TK_FOLLOWING && (eEnd == TK_PRECEDING ||
					eEnd == TK_CURRENT))) {
		diag_set(ClientError, ER_SQL_PARSER_GENERIC,
			 "unsupported window-frame type");
		pParse->is_aborted = true;
		return NULL;
	}

	Window *pWin = (Window *)sql_xmalloc0(sizeof(Window));
	pWin->eType = eType;
	pWin->eStart = eStart;
	pWin->eEnd = eEnd;
	pWin->bImplicitFrame = bImplicitFrame;
	pWin->pEnd = sqlWindowOffsetExpr(pEnd);
	pWin->pStart = sqlWindowOffsetExpr(pStart);
	return pWin;
}

/*
 ** Attach PARTITION and ORDER BY clauses pPartition and pOrderBy to window
 ** pWin. Also, if parameter pBase is not NULL, set pWin->zBase to the
 ** equivalent nul-terminated string.
 */
Window *
sqlWindowAssemble(Window *pWin, ExprList *pPartition, ExprList *pOrderBy,
		  Token *pBase)
{
	if (pWin) {
		pWin->pPartition = pPartition;
		pWin->pOrderBy = pOrderBy;
		if (pBase)
			pWin->zBase = sql_xstrndup(pBase->z,
						   pBase->n);
	} else {
		sql_expr_list_delete(pPartition);
		sql_expr_list_delete(pOrderBy);
	}
	return pWin;
}

/*
 ** Window *pWin has just been created from a WINDOW clause. Tokne pBase
 ** is the base window. Earlier windows from the same WINDOW clause are
 ** stored in the linked list starting at pWin->pNextWin. This function
 ** either updates *pWin according to the base specification, or else
 ** leaves an error in pParse.
 */
void
sqlWindowChain(Parse *pParse, Window *pWin, Window *pList)
{
	if (pWin->zBase == NULL)
		return;
	Window *pExist = windowFind(pParse, pList, pWin->zBase);
	if (pExist) {
		const char *zErr = 0;
		/* Check for errors */
		if (pWin->pPartition)
			zErr = "PARTITION clause";
		else if (pExist->pOrderBy && pWin->pOrderBy)
			zErr = "ORDER BY clause";
		else if (pExist->bImplicitFrame == 0)
			zErr = "frame specification";
		if (zErr) {
			const char *err_msg;
			err_msg = tt_sprintf("cannot override %s of window: %s",
					     zErr, pWin->zBase);
			diag_set(ClientError, ER_SQL_PARSER_GENERIC, err_msg);
			pParse->is_aborted = true;
			return;
		} else {
			pWin->pPartition = sql_expr_list_dup(pExist->pPartition, 0);
			if (pExist->pOrderBy) {
				assert(pWin->pOrderBy == 0);
				pWin->pOrderBy = sql_expr_list_dup(pExist->pOrderBy, 0);
			}
			pWin->zBase = 0;
		}
	}
}

/*
 * Attach window object pWin to expression p.
 */
void
sqlWindowAttach(Parse *pParse, Expr *p, Window *pWin)
{
	if (p) {
		assert(p->op == TK_FUNCTION);
		if (pWin != NULL) {
			p->y.pWin = pWin;
			ExprSetProperty(p, EP_WinFunc);
			pWin->pOwner = p;
			if (p->flags & EP_Distinct) {
				diag_set(ClientError, ER_SQL_PARSER_GENERIC,
					 "DISTINCT is not supported "
					 "for window functions");
				pParse->is_aborted = true;
			}
		}
	} else {
		sqlWindowDelete(pWin);
	}
}

/*
 * Return 0 if the two window objects are identical, or non-zero otherwise.
 * Identical window objects can be processed in a single scan.
 */
int
sqlWindowCompare(Window *p1, Window *p2)
{
	if (p1->eType != p2->eType)
		return 1;
	if (p1->eStart != p2->eStart)
		return 1;
	if (p1->eEnd != p2->eEnd)
		return 1;
	if (sqlExprCompare(p1->pStart, p2->pStart, -1))
		return 1;
	if (sqlExprCompare(p1->pEnd, p2->pEnd, -1))
		return 1;
	if (sqlExprListCompare(p1->pPartition, p2->pPartition, -1))
		return 1;
	if (sqlExprListCompare(p1->pOrderBy, p2->pOrderBy, -1))
		return 1;
	return 0;
}

/*
 * This is called by code in select.c before it calls sqlWhereBegin()
 * to begin iterating through the sub-query results. It is used to allocate
 * and initialize registers and cursors used by sqlWindowCodeStep().
 */
void
sqlWindowCodeInit(Parse *pParse, Window *pMWin)
{
	Window *pWin;
	Vdbe *v = sqlGetVdbe(pParse);
	int nPart = (pMWin->pPartition ? pMWin->pPartition->nExpr : 0);
	nPart += (pMWin->pOrderBy ? pMWin->pOrderBy->nExpr : 0);
	if (nPart) {
		pMWin->regPart = pParse->nMem + 1;
		pParse->nMem += nPart;
		sqlVdbeAddOp3(v, OP_Null, 0, pMWin->regPart,
			      pMWin->regPart + nPart - 1);
	}

	pMWin->regFirst = ++pParse->nMem;
	sqlVdbeAddOp2(v, OP_Bool, 1, pMWin->regFirst);

	for (pWin = pMWin; pWin; pWin = pWin->pNextWin) {
		struct func *p = pWin->pFunc;
		uint32_t flags = sql_func_flags(p->def->name);
		bool is_minmax = (flags & SQL_FUNC_MIN) ||
				 (flags & SQL_FUNC_MAX);
		if (is_minmax && pWin->eStart != TK_UNBOUNDED) {
			/* The inline versions of min() and max()
			 * require a single ephemeral table and 3 registers.
			 * The registers are used as follows:
			 *
			 *	regApp+0: slot to copy min()/max()
			 *	argument to for MakeRecord
			 *	regApp+1: integer value used
			 *	to ensure keys are unique
			 *	regApp+2: output of MakeRecord
			 */
			ExprList *pList = pWin->pOwner->x.pList;
			/*
			 * Ephemeral table requires PK,
			 * so append a rowid to the end
			 * of the list. Rowid acts as a primary key
			 * for the ephemeral table.
			 */
			struct sql_space_info *info;
			info = sql_space_info_new_from_expr_list(pParse,
								 pList, true);
			pWin->csrApp = pParse->nTab++;
			pWin->regAppCsr = pParse->nMem + 1;
			++pParse->nMem;
			pWin->regApp = pParse->nMem + 1;
			pParse->nMem += 3;

			sqlVdbeAddOp4(v, OP_OpenTEphemeral,
				      pWin->regAppCsr, 0, 0,
				      (char *)info, P4_DYNAMIC);
			sqlVdbeAddOp3(v, OP_IteratorOpen, pWin->csrApp, 0,
				      pWin->regAppCsr);
			sqlVdbeAddOp2(v, OP_Integer, 0, pWin->regApp + 1);
		}
	}
}

/*
 * A "PRECEDING <expr>" (bEnd==0) or "FOLLOWING <expr>" (bEnd==1) has just
 * been evaluated and the result left in register reg. This function generates
 * VM code to check that the value is a non-negative integer and throws
 * an exception if it is not.
 */
static void
windowCheckIntValue(Parse *pParse, int reg, int eCond)
{
	static const char *const azErr[] = {
		"frame starting offset must be a non-negative integer",
		"frame ending offset must be a non-negative integer"
	};
	static int aOp[] = { OP_Ge, OP_Ge };
	Vdbe *v = sqlGetVdbe(pParse);
	int regZero = sqlGetTempReg(pParse);
	assert(eCond == 0 || eCond == 1);
	sqlVdbeAddOp2(v, OP_Integer, 0, regZero);
	sqlVdbeAddOp2(v, OP_MustBeInt, reg, sqlVdbeCurrentAddr(v) + 2);
	sqlVdbeAddOp3(v, aOp[eCond], regZero, sqlVdbeCurrentAddr(v) + 2, reg);
	sqlVdbeAddOp2(v, OP_Halt, -1, ON_CONFLICT_ACTION_ABORT);
	sqlVdbeAppendP4(v, (void *)azErr[eCond], P4_STATIC);
	sqlReleaseTempReg(pParse, regZero);
}

/*
 * Return the number of arguments passed to the window-function associated
 * with the object passed as the only argument to this function.
 */
static int
windowArgCount(Window *pWin)
{
	ExprList *pList = pWin->pOwner->x.pList;
	return pList ? pList->nExpr : 0;
}

/*
 * Generate VM code to invoke either xStep() (if bInverse is 0) or
 * xInverse (if bInverse is non-zero) for each window function in the
 * linked list starting at pMWin. Or, for built-in window functions
 * that do not use the standard function API, generate the required
 * inline VM code.
 *
 * If argument csr is greater than or equal to 0, then argument reg is
 * the first register in an array of registers guaranteed to be large
 * enough to hold the array of arguments for each function. In this case
 * the arguments are extracted from the current row of csr into the
 * array of registers before invoking OP_AggStep.
 *
 * Or, if csr is less than zero, then the array of registers at reg is
 * already populated with all columns from the current row of the sub-query.
 *
 * If argument regPartSize is non-zero, then it is a register containing the
 * number of rows in the current partition.
 */
static void
windowAggStep(
	Parse *pParse,
	Window *pMWin,		/* Linked list of window functions */
	int csr,		/* Read arguments from this cursor */
	int bInverse,		/* True to invoke xInverse instead of xStep */
	int reg,		/* Array of registers */
	int regPartSize)	/* Register containing size of partition */
{
	(void)regPartSize;
	Vdbe *v = sqlGetVdbe(pParse);
	Window *pWin;
	int regHit = 0;
	for (pWin = pMWin; pWin; pWin = pWin->pNextWin) {
		uint32_t flags = sql_func_flags(pWin->pFunc->def->name);
		int regArg;
		int nArg = windowArgCount(pWin);

		if (csr >= 0) {
			int i;
			for (i = 0; i < nArg; i++) {
				sqlVdbeAddOp3(v, OP_Column, csr,
					      pWin->iArgCol + i, reg + i);
			}
			regArg = reg;
		} else {
			regArg = reg + pWin->iArgCol;
		}

		bool is_minmax = (flags & SQL_FUNC_MIN) ||
				 (flags & SQL_FUNC_MAX);
		if (is_minmax && pWin->eStart != TK_UNBOUNDED) {
			int addrIsNull = sqlVdbeAddOp1(v, OP_IsNull, regArg);
			if (bInverse == 0) {
				sqlVdbeAddOp2(v, OP_AddImm,
					      pWin->regApp + 1, 1);
				sqlVdbeAddOp2(v, OP_SCopy,
					      regArg, pWin->regApp);
				sqlVdbeAddOp3(v, OP_MakeRecord, pWin->regApp, 2,
					      pWin->regApp + 2);
				sqlVdbeChangeP5(v, 1);
				sqlVdbeAddOp2(v, OP_IdxInsert, pWin->regApp + 2,
					      pWin->regAppCsr);
			} else {
				sqlVdbeAddOp4Int(v, OP_SeekGE, pWin->csrApp, 0,
						 regArg, 1);
				sqlVdbeAddOp1(v, OP_Delete, pWin->csrApp);
				sqlVdbeJumpHere(v, sqlVdbeCurrentAddr(v) - 2);
			}
			sqlVdbeJumpHere(v, addrIsNull);
		} else {
			int addrIf = 0;
			struct coll *coll = NULL;
			if (pWin->pFilter) {
				int regTmp;
				assert(nArg == 0 ||
				       nArg == pWin->pOwner->x.pList->nExpr);
				assert(nArg || pWin->pOwner->x.pList == 0);
				if (csr > 0) {
					regTmp = sqlGetTempReg(pParse);
					sqlVdbeAddOp3(v, OP_Column, csr,
						      pWin->iArgCol + nArg,
						      regTmp);
				} else {
					regTmp = regArg + nArg;
				}
				addrIf = sqlVdbeAddOp3(v, OP_IfNot,
						       regTmp, 0, 1);
				if (csr > 0) {
					sqlReleaseTempReg(pParse, regTmp);
				}
			}
			if (flags &SQL_FUNC_NEEDCOLL) {
				bool unused;
				uint32_t id;
				assert(nArg > 0);
				Expr *pExpr = pWin->pOwner->x.pList->a[0].pExpr;
				if (sql_expr_coll(pParse, pExpr, &unused, &id,
						  &coll) != 0) {
					coll = NULL;
				}
				if (regHit == 0)
					regHit = ++pParse->nMem;
				sqlVdbeAddOp1(v, OP_SkipLoad, regHit);
			}
			struct sql_context *ctx = sql_context_new(pWin->pFunc,
								  coll);
			if (bInverse)
				ctx->funcFlag |= SQL_CTX_INVERSE;
			sqlVdbeAddOp3(v, OP_AggStep, nArg, regArg,
				      pWin->regAccum);
			sqlVdbeAppendP4(v, ctx, P4_FUNCCTX);
			if (addrIf)
				sqlVdbeJumpHere(v, addrIf);
		}
	}
}

/*
 * Generate VM code to invoke either xValue() (bFinal==0) or xFinalize()
 * (bFinal==1) for each window function in the linked list starting at
 * pMWin. Or, for built-in window-functions that do not use the standard
 * API, generate the equivalent VM code.
 */
static void
windowAggFinal(Parse *pParse, Window *pMWin, int bFinal)
{
	Vdbe *v = sqlGetVdbe(pParse);
	Window *pWin;

	for (pWin = pMWin; pWin; pWin = pWin->pNextWin) {
		uint32_t flags = sql_func_flags(pWin->pFunc->def->name);
		bool is_minmax = (flags &SQL_FUNC_MIN) ||
				 (flags &SQL_FUNC_MAX);
		if (is_minmax && pWin->eStart != TK_UNBOUNDED) {
			sqlVdbeAddOp2(v, OP_Null, 0, pWin->regResult);
			if (flags &SQL_FUNC_MIN)
				sqlVdbeAddOp3(v, OP_Rewind, pWin->csrApp, 0, 0);
			else
				sqlVdbeAddOp3(v, OP_Last, pWin->csrApp, 0, 0);
			sqlVdbeAddOp3(v, OP_Column, pWin->csrApp, 0,
				      pWin->regResult);
			sqlVdbeJumpHere(v, sqlVdbeCurrentAddr(v) - 2);
			if (bFinal) {
				sqlVdbeAddOp1(v, OP_ResetSorter, pWin->csrApp);
			}
		} else if (pWin->regApp) {
		} else {
			if (bFinal == 0) {
				sqlVdbeAddOp2(v, OP_Null, 0, pWin->regResult);
			}
			sqlVdbeAddOp1(v, OP_AggFinal, pWin->regAccum);
			sqlVdbeAppendP4(v, pWin->pFunc, P4_FUNC);
			if (bFinal) {
				sqlVdbeAddOp2(v, OP_Copy, pWin->regAccum,
					      pWin->regResult);
				sqlVdbeAddOp2(v, OP_Null, 0, pWin->regAccum);
			} else {
				sqlVdbeChangeP3(v, -1, pWin->regResult);
			}
		}
	}
}

/*
 * Invoke the sub-routine at regGosub (generated by code in select.c) to
 * return the current row of Window.iEphCsr. If all window functions are
 * aggregate window functions that use the standard API, a single
 * OP_Gosub instruction is all that this routine generates.
 */
static void
windowReturnOneRow(
	Parse *pParse,
	Window *pMWin,
	int regGosub,
	int addrGosub)
{
	(void)pMWin;
	Vdbe *v = sqlGetVdbe(pParse);
	sqlVdbeAddOp2(v, OP_Gosub, regGosub, addrGosub);
}

/*
 * Generate code to set the accumulator register for each window function
 * in the linked list passed as the second argument to NULL. And perform
 * any equivalent initialization required by any built-in window functions
 * in the list.
 */
static int
windowInitAccum(Parse *pParse, Window *pMWin)
{
	Vdbe *v = sqlGetVdbe(pParse);
	int regArg;
	int nArg = 0;
	Window *pWin;
	for (pWin = pMWin; pWin; pWin = pWin->pNextWin) {
		uint32_t flags = sql_func_flags(pWin->pFunc->def->name);
		sqlVdbeAddOp2(v, OP_Null, 0, pWin->regAccum);
		nArg = MAX(nArg, windowArgCount(pWin));
		bool is_minmax = (flags &SQL_FUNC_MIN) ||
				 (flags &SQL_FUNC_MAX);
		if (is_minmax && pWin->csrApp) {
			assert(pWin->eStart != TK_UNBOUNDED);
			sqlVdbeAddOp1(v, OP_ResetSorter, pWin->csrApp);
			sqlVdbeAddOp2(v, OP_Integer, 0, pWin->regApp + 1);
		}
	}
	regArg = pParse->nMem + 1;
	pParse->nMem += nArg;
	return regArg;
}

/*
** regOld and regNew are each the first register in an array of size
** pOrderBy->nExpr. This function generates code to compare the two
** arrays of registers using the collation sequences and other comparison
** parameters specified by pOrderBy.
**
** If the two arrays are not equal, the contents of regNew is copied to
** regOld and control falls through. Otherwise, if the contents of the arrays
** are equal, an OP_Goto is executed. The address of the OP_Goto is returned.
*/
static int windowIfNewPeer(
	Parse *pParse,
	ExprList *pOrderBy,
	int regNew,                     /* First in array of new values */
	int regOld                      /* First in array of old values */
){
	Vdbe *v = sqlGetVdbe(pParse);
	int addr;
	if( pOrderBy ){
		int nVal = pOrderBy->nExpr;
		struct sql_key_info *pKeyInfo = sql_expr_list_to_key_info(pParse, pOrderBy, 0);
		sqlVdbeAddOp3(v, OP_Compare, regOld, regNew, nVal);
		sqlVdbeAppendP4(v, (void*)pKeyInfo, P4_KEYINFO);
		addr = sqlVdbeAddOp3(v, OP_Jump, sqlVdbeCurrentAddr(v) + 1,
				     0, sqlVdbeCurrentAddr(v) + 1);
		sqlVdbeAddOp3(v, OP_Copy, regNew, regOld, nVal - 1);
	}else{
		addr = sqlVdbeAddOp0(v, OP_Goto);
	}
	return addr;
}

typedef struct WindowCodeArg WindowCodeArg;
typedef struct WindowCsrAndReg WindowCsrAndReg;
struct WindowCsrAndReg {
	int csr;
	int reg;
};
struct WindowCodeArg {
	Parse *pParse;
	Window *pMWin;
	Vdbe *pVdbe;
	int regGosub;
	int addrGosub;
	int regArg;

	WindowCsrAndReg start;
	WindowCsrAndReg current;
	WindowCsrAndReg end;
};

#define WINDOW_RETURN_ROW 1
#define WINDOW_AGGINVERSE 2
#define WINDOW_AGGSTEP    3

/*
** Generate VM code to read the window frames peer values from cursor csr into
** an array of registers starting at reg.
*/
static void windowReadPeerValues(
	WindowCodeArg *p,
	int csr,
	int reg
){
	Window *pMWin = p->pMWin;
	ExprList *pOrderBy = pMWin->pOrderBy;
	if( pOrderBy ){
		Vdbe *v = sqlGetVdbe(p->pParse);
		ExprList *pPart = pMWin->pPartition;
		int iColOff = pMWin->nBufferCol + (pPart ? pPart->nExpr : 0);
		int i;
		for(i=0; i<pOrderBy->nExpr; i++){
			sqlVdbeAddOp3(v, OP_Column, csr, iColOff+i, reg+i);
		}
	}
}

static int
windowCodeOp(WindowCodeArg *p, int op,
	     int regCountdown, int jumpOnEof)
{
	int csr, reg;
	Parse *pParse = p->pParse;
	Window *pMWin = p->pMWin;
	int ret = 0;
	Vdbe *v = p->pVdbe;
	int addrIf = 0;
	int addrContinue = 0;
	int addrGoto = 0;
	int bPeer = (pMWin->eType!=TK_ROWS);

	/* Special case - WINDOW_AGGINVERSE is always a no-op if the frame
	** starts with UNBOUNDED PRECEDING. */
	if( op==WINDOW_AGGINVERSE && pMWin->eStart==TK_UNBOUNDED ){
		assert( regCountdown==0 && jumpOnEof==0 );
		return 0;
	}

	if (regCountdown > 0)
		addrIf = sqlVdbeAddOp3(v, OP_IfPos, regCountdown, 0, 1);

	if( op==WINDOW_RETURN_ROW ){
		windowAggFinal(pParse, pMWin, 0);
	}
	addrContinue = sqlVdbeCurrentAddr(v);
	switch (op) {
	case WINDOW_RETURN_ROW:
		csr = p->current.csr;
		reg = p->current.reg;
		windowReturnOneRow(pParse, pMWin, p->regGosub, p->addrGosub);
	break;

	case WINDOW_AGGINVERSE:
		csr = p->start.csr;
		reg = p->start.reg;
		windowAggStep(pParse, pMWin, csr, 1, p->regArg, 0);
	break;

	case WINDOW_AGGSTEP:
		csr = p->end.csr;
		reg = p->end.reg;
		windowAggStep(pParse, pMWin, csr, 0, p->regArg, 0);
	break;
	}

	if (jumpOnEof) {
		sqlVdbeAddOp2(v, OP_Next, csr, sqlVdbeCurrentAddr(v) + 2);
		ret = sqlVdbeAddOp0(v, OP_Goto);
	} else {
		sqlVdbeAddOp2(v, OP_Next, csr, sqlVdbeCurrentAddr(v)+1+bPeer);
		if( bPeer ){
			addrGoto = sqlVdbeAddOp0(v, OP_Goto);
		}
	}

	if( bPeer ){
		int addr;
		int nReg = (pMWin->pOrderBy ? pMWin->pOrderBy->nExpr : 0);
		int regTmp = (nReg ? sqlGetTempRange(pParse, nReg) : 0);
		windowReadPeerValues(p, csr, regTmp);
		addr = windowIfNewPeer(pParse, pMWin->pOrderBy, regTmp, reg);
		sqlVdbeChangeP2(v, addr, addrContinue);
		sqlReleaseTempRange(pParse, regTmp, nReg);
	}

	if( addrGoto ) sqlVdbeJumpHere(v, addrGoto);
	if( addrIf ) sqlVdbeJumpHere(v, addrIf);
	return ret;
}

/*
 * Allocate and return a duplicate of the Window object indicated by the
 * third argument. Set the Window.pOwner field of the new object to
 * pOwner.
 */
Window *
sqlWindowDup(Expr *pOwner, Window *p)
{
	Window *pNew = 0;
	if (ALWAYS(p)) {
		pNew = sql_xmalloc0(sizeof(Window));
		pNew->zName = sql_xstrdup(p->zName);
		pNew->pFilter = sqlExprDup(p->pFilter, 0);
		pNew->pFunc = p->pFunc;
		pNew->pPartition = sql_expr_list_dup(p->pPartition, 0);
		pNew->pOrderBy = sql_expr_list_dup(p->pOrderBy, 0);
		pNew->eType = p->eType;
		pNew->eEnd = p->eEnd;
		pNew->eStart = p->eStart;
		pNew->pStart = sqlExprDup(p->pStart, 0);
		pNew->pEnd = sqlExprDup(p->pEnd, 0);
		pNew->pOwner = pOwner;
	}
	return pNew;
}

/*
 * Return a copy of the linked list of Window objects passed as the
 * second argument.
 */
Window *
sqlWindowListDup(Window *p)
{
	Window *pWin;
	Window *pRet = 0;
	Window **pp = &pRet;

	for (pWin = p; pWin; pWin = pWin->pNextWin) {
		*pp = sqlWindowDup(0, pWin);
		if (*pp == 0)
			break;
		pp = &((*pp)->pNextWin);
	}

	return pRet;
}

/*
** sqlite3WhereBegin() has already been called for the SELECT statement
** passed as the second argument when this function is invoked. It generates
** code to populate the Window.regResult register for each window function
** and invoke the sub-routine at instruction addrGosub once for each row.
** sqlite3WhereEnd() is always called before returning.
**
** This function handles several different types of window frames, which
** require slightly different processing. The following pseudo code is
** used to implement window frames of the form:
 **
 **     ROWS BETWEEN <expr1> PRECEDING AND <expr2> FOLLOWING
 **
** Other window frame types use variants of the following:
**
**     ... loop started by sqlite3WhereBegin() ...
**       if( new partition ){
**         Gosub flush
**       }
**       Insert new row into eph table.
**
**       if( first row of partition ){
**         // Rewind three cursors, all open on the eph table.
**         Rewind(csrEnd);
**         Rewind(csrStart);
**         Rewind(csrCurrent);
**
**         regEnd = <expr2>          // FOLLOWING expression
**         regStart = <expr1>        // PRECEDING expression
**       }else{
**         // First time this branch is taken, the eph table contains two
**         // rows. The first row in the partition, which all three cursors
**         // currently point to, and the following row.
**         AGGSTEP
**         if( (regEnd--)<=0 ){
**           RETURN_ROW
**           if( (regStart--)<=0 ){
**             AGGINVERSE
**           }
**         }
**       }
**     }
**     flush:
**       AGGSTEP
**       while( 1 ){
**         RETURN ROW
**         if( csrCurrent is EOF ) break;
**         if( (regStart--)<=0 ){
**           AggInverse(csrStart)
**           Next(csrStart)
**         }
**       }
**
** The pseudo-code above uses the following shorthand:
**
**   AGGSTEP:    invoke the aggregate xStep() function for each window function
**               with arguments read from the current row of cursor csrEnd, then
**               step cursor csrEnd forward one row (i.e. sqlite3BtreeNext()).
**
**   RETURN_ROW: return a row to the caller based on the contents of the
**               current row of csrCurrent and the current state of all
**               aggregates. Then step cursor csrCurrent forward one row.
**
**   AGGINVERSE: invoke the aggregate xInverse() function for each window
**               functions with arguments read from the current row of cursor
**               csrStart. Then step csrStart forward one row.
**
** There are two other ROWS window frames that are handled significantly
** differently from the above - "BETWEEN <expr> PRECEDING AND <expr> PRECEDING"
** and "BETWEEN <expr> FOLLOWING AND <expr> FOLLOWING". These are special
** cases because they change the order in which the three cursors (csrStart,
** csrCurrent and csrEnd) iterate through the ephemeral table. Cases that
** use UNBOUNDED or CURRENT ROW are much simpler variations on one of these
** three.
**
**   ROWS BETWEEN <expr1> PRECEDING AND <expr2> PRECEDING
**
**     ... loop started by sqlite3WhereBegin() ...
**       if( new partition ){
**         Gosub flush
**       }
**       Insert new row into eph table.
**       if( first row of partition ){
**         Rewind(csrEnd)
**         Rewind(csrStart)
**         Rewind(csrCurrent)
**         regEnd = <expr2>
**         regStart = <expr1>
**       }else{
**         if( (regEnd--)<=0 ){
**           AGGSTEP
**         }
**         RETURN_ROW
**         if( (regStart--)<=0 ){
**           AGGINVERSE
**         }
**       }
**     }
**     flush:
**       if( (regEnd--)<=0 ){
**         AGGSTEP
**       }
**       RETURN_ROW
**
**
**   ROWS BETWEEN <expr1> FOLLOWING AND <expr2> FOLLOWING
**
**     ... loop started by sqlite3WhereBegin() ...
**     if( new partition ){
**       Gosub flush
**     }
**     Insert new row into eph table.
**     if( first row of partition ){
**       Rewind(csrEnd)
**       Rewind(csrStart)
**       Rewind(csrCurrent)
**       regEnd = <expr2>
**       regStart = regEnd - <expr1>
**     }else{
**       AGGSTEP
**       if( (regEnd--)<=0 ){
**         RETURN_ROW
**       }
**       if( (regStart--)<=0 ){
**         AGGINVERSE
**       }
**     }
**   }
**   flush:
**     AGGSTEP
**     while( 1 ){
**       if( (regEnd--)<=0 ){
**         RETURN_ROW
**         if( eof ) break;
**       }
**       if( (regStart--)<=0 ){
**         AGGINVERSE
**         if( eof ) break
**       }
**     }
**     while( !eof csrCurrent ){
**       RETURN_ROW
**     }
**
** For the most part, the patterns above are adapted to support UNBOUNDED by
** assuming that it is equivalent to "infinity PRECEDING/FOLLOWING" and
** CURRENT ROW by assuming that it is equivilent to "0 PRECEDING/FOLLOWING".
** This is optimized of course - branches that will never be taken and
** conditions that are always true are omitted from the VM code. The only
** exceptional case is:
**
**   ROWS BETWEEN <expr1> FOLLOWING AND UNBOUNDED FOLLOWING
**
**     ... loop started by sqlite3WhereBegin() ...
**     if( new partition ){
**       Gosub flush
**     }
**     Insert new row into eph table.
**     if( first row of partition ){
**       Rewind(csrEnd)
**       Rewind(csrStart)
**       Rewind(csrCurrent)
**       regStart = <expr1>
**     }else{
**       AGGSTEP
**     }
**   }
**   flush:
**     AGGSTEP
**     while( 1 ){
**       if( (regStart--)<=0 ){
**         AGGINVERSE
**         if( eof ) break
**       }
**       RETURN_ROW
**     }
**     while( !eof csrCurrent ){
**       RETURN_ROW
**     }
*/
void
sqlWindowCodeStep(
	Parse *pParse,	          /* Parse context */
	Select *p,                /* Rewritten SELECT statement */
	WhereInfo *pWInfo,        /* Context returned by sqlite3WhereBegin() */
	int regGosub,             /* Register for OP_Gosub */
	int addrGosub             /* OP_Gosub here to return each row */
)
{
	Window *pMWin = p->pWin;
	ExprList *pOrderBy = pMWin->pOrderBy;
	Vdbe *v = sqlGetVdbe(pParse);
	int regFlushPart;               /* Register for "Gosub flush_partition" */
	int csrWrite;                   /* Cursor used to write to eph. table */
	int csrInput = p->pSrc->a[0].iCursor;     /* Cursor of sub-select */
	int nInput = p->pSrc->a[0].space->def->field_count;    /* Number of cols returned by sub */
	int iInput;                     /* To iterate through sub cols */
	int addrGoto;                   /* Address of OP_Goto */
	int addrIf;                     /* NOTE(gmoshkin): this is removed in commit 72b9fdcf2 */
	int addrIfNot;                  /* Address of OP_IfNot */
	int addrGosubFlush = -1;        /* Address of OP_Gosub to flush: */
	int addrInteger = -1;           /* Address of OP_Integer */
	int addrShortcut = 0;
	int addrEmpty = 0;              /* Address of OP_Rewind in flush: */
	int addrPeerJump = 0;           /* Address of jump taken if not new peer */
	int regStart = 0;               /* Value of <expr> PRECEDING */
	int regEnd = 0;                 /* Value of <expr> FOLLOWING */
	int regNew;                     /* Array of registers holding new input row */
	int regRecord;                  /* regNew array in record form */
	int regRowid;                   /* Rowid for regRecord in eph table */
	int regNewPeer = 0;             /* Peer values for new row (part of regNew) */
	int regPeer = 0;                /* Peer values for current row */
	WindowCodeArg s;                /* Context object for sub-routines */

	assert( pMWin->eStart==TK_PRECEDING || pMWin->eStart==TK_CURRENT
	     || pMWin->eStart==TK_FOLLOWING || pMWin->eStart==TK_UNBOUNDED
	);
	assert( pMWin->eEnd==TK_FOLLOWING || pMWin->eEnd==TK_CURRENT
	     || pMWin->eEnd==TK_UNBOUNDED || pMWin->eEnd==TK_PRECEDING
	);

	/* Fill in the context object */
	memset(&s, 0, sizeof(WindowCodeArg));
	s.pParse = pParse;
	s.pMWin = pMWin;
	s.pVdbe = v;
	s.regGosub = regGosub;
	s.addrGosub = addrGosub;
	s.current.csr = pMWin->iEphCsr;
	csrWrite = pMWin->iEphCsr+1;
	s.start.csr = s.current.csr+2;
	s.end.csr = s.current.csr+3;

	regNew = pParse->nMem+1;
	pParse->nMem += nInput;
	/* NOTE: in the original sqlite source this is inverted,
	 * i.e. regRowid = regRecord + 1;
	 * We need to swap these, because in our case rowid (the primary key)
	 * must be added to the tuple (and we put it at the end of the tuple).
	 * MakeRecord VDBE operation constructs a tuple from a contiguous region
	 * of registers, so in this case the tuple's columns start at `reg` and
	 * end at `regRowid` (inclusive). The next register is the regRecord
	 * where the constructed tuple goes.
	 */
	regRowid = ++pParse->nMem;
	regRecord = ++pParse->nMem;
	regFlushPart = ++pParse->nMem;

	/* If the window frame contains an "<expr> PRECEDING" or "<expr> FOLLOWING"
	** clause, allocate registers to store the results of evaluating each
	** <expr>.  */
	if( pMWin->eStart==TK_PRECEDING || pMWin->eStart==TK_FOLLOWING  ){
		regStart = ++pParse->nMem;
	}
	if( pMWin->eEnd==TK_PRECEDING || pMWin->eEnd==TK_FOLLOWING  ){
		regEnd = ++pParse->nMem;
	}

	/* If this is not a "ROWS BETWEEN ..." frame, then allocate arrays of
	** registers to store copies of the ORDER BY expressions (peer values)
	** for the main loop, and for each cursor (start, current and end). */
	if( pMWin->eType!=TK_ROWS ){
		int nPeer = (pOrderBy ? pOrderBy->nExpr : 0);
		regNewPeer = regNew + pMWin->nBufferCol;
		if( pMWin->pPartition ) regNewPeer += pMWin->pPartition->nExpr;
		regPeer = pParse->nMem+1;       pParse->nMem += nPeer;
		s.start.reg = pParse->nMem+1;   pParse->nMem += nPeer;
		s.current.reg = pParse->nMem+1; pParse->nMem += nPeer;
		s.end.reg = pParse->nMem+1;     pParse->nMem += nPeer;
	}

	/* Load the column values for the row returned by the sub-select
	** into an array of registers starting at regNew. Assemble them into
	** a record in register regRecord. */
	for (iInput = 0; iInput < nInput; iInput++) {
		sqlVdbeAddOp3(v, OP_Column, csrInput, iInput, regNew + iInput);
	}
	sqlVdbeAddOp3(v, OP_MakeRecord, regNew, nInput, regRecord);

	/* An input row has just been read into an array of registers starting
	 ** at regNew. If the window has a PARTITION clause, this block generates
	 ** VM code to check if the input row is the start of a new partition.
	 ** If so, it does an OP_Gosub to an address to be filled in later. The
	 ** address of the OP_Gosub is stored in local variable addrGosubFlush. */
	if (pMWin->pPartition) {
		int addr;
		struct sql_key_info *key_info;
		ExprList *pPart = pMWin->pPartition;
		int nPart = pPart->nExpr;
		int regNewPart = regNew + pMWin->nBufferCol;
		key_info = sql_expr_list_to_key_info(pParse, pPart, 0);

		addrIf = sqlVdbeAddOp1(v, OP_If, pMWin->regFirst);
		addr = sqlVdbeAddOp3(v, OP_Compare, regNewPart, pMWin->regPart,
				     nPart);
		sqlVdbeAppendP4(v, (void *)key_info, P4_KEYINFO);
		sqlVdbeAddOp3(v, OP_Jump, addr + 2, addr + 4, addr + 2);
		addrGosubFlush = sqlVdbeAddOp1(v, OP_Gosub, regFlushPart);
		VdbeComment((v, "call flush_partition"));
		sqlVdbeJumpHere(v, addrIf);
		sqlVdbeAddOp3(v, OP_Copy, regNewPart, pMWin->regPart,
			      nPart - 1);
	}

	/* Insert the new row into the ephemeral table */
	/* NOTE(gmoshkin) different from sqlite */
	assert(regRowid == regNew + nInput);
	sqlVdbeAddOp2(v, OP_NextIdEphemeral, pMWin->regEph, regRowid);
	sqlVdbeAddOp3(v, OP_MakeRecord, regNew, nInput + 1, regRecord);
	sqlVdbeChangeP5(v, 1);
	sqlVdbeAddOp2(v, OP_IdxInsert, regRecord, pMWin->regEph);

	addrIfNot = sqlVdbeAddOp1(v, OP_IfNot, pMWin->regFirst);

	/* This block is run for the first row of each partition */
	s.regArg = windowInitAccum(pParse, pMWin);

	if( regStart ){
		sqlExprCode(pParse, pMWin->pStart, regStart);
		windowCheckIntValue(pParse, regStart, 0);
	}
	if( regEnd  ){
		sqlExprCode(pParse, pMWin->pEnd, regEnd);
		windowCheckIntValue(pParse, regEnd, 1);
	}

	if( pMWin->eStart == pMWin->eEnd && regStart && regEnd ){
		int op = ((pMWin->eStart == TK_FOLLOWING) ? OP_Ge : OP_Le);
		int addrGe = sqlVdbeAddOp3(v, op, regStart, 0, regEnd);
		windowAggFinal(pParse, pMWin, 0);
		sqlVdbeAddOp2(v, OP_Rewind, s.current.csr, 1);
		windowReturnOneRow(pParse, pMWin, regGosub, addrGosub);
		sqlVdbeAddOp1(v, OP_ResetSorter, s.current.csr);
		addrShortcut = sqlVdbeAddOp0(v, OP_Goto);
		sqlVdbeJumpHere(v, addrGe);
	}
	if (pMWin->eStart == TK_FOLLOWING && regEnd) {
		assert( pMWin->eEnd==TK_FOLLOWING );
		sqlVdbeAddOp3(v, OP_Subtract, regStart, regEnd, regStart);
	}

	if( pMWin->eStart!=TK_UNBOUNDED ){
		sqlVdbeAddOp2(v, OP_Rewind, s.start.csr, 1);
	}
	sqlVdbeAddOp2(v, OP_Rewind, s.current.csr, 1);
	sqlVdbeAddOp2(v, OP_Rewind, s.end.csr, 1);
	if( regPeer && pOrderBy ){
		sqlVdbeAddOp3(v, OP_Copy, regNewPeer, regPeer, pOrderBy->nExpr-1);
		sqlVdbeAddOp3(v, OP_Copy, regPeer, s.start.reg, pOrderBy->nExpr-1);
		sqlVdbeAddOp3(v, OP_Copy, regPeer, s.current.reg, pOrderBy->nExpr-1);
		sqlVdbeAddOp3(v, OP_Copy, regPeer, s.end.reg, pOrderBy->nExpr-1);
	}

	sqlVdbeAddOp2(v, OP_Bool, 0, pMWin->regFirst);
	addrGoto = sqlVdbeAddOp0(v, OP_Goto);

	/* Begin generating SECOND_ROW_CODE */
	VdbeComment((v, "Begin windowCodeStep.SECOND_ROW"));
	sqlVdbeJumpHere(v, addrIfNot);
	if( regPeer ){
		addrPeerJump = windowIfNewPeer(pParse, pOrderBy, regNewPeer, regPeer);
	}

	if (pMWin->eStart == TK_FOLLOWING) {
		windowCodeOp(&s, WINDOW_AGGSTEP, 0, 0);
		if( pMWin->eEnd!=TK_UNBOUNDED ){
			windowCodeOp(&s, WINDOW_RETURN_ROW, regEnd, 0);
			windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);
		}
	} else if (pMWin->eEnd == TK_PRECEDING) {
		windowCodeOp(&s, WINDOW_AGGSTEP, regEnd, 0);
		windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 0);
		windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);
	} else {
		int addr;
		windowCodeOp(&s, WINDOW_AGGSTEP, 0, 0);
		if( pMWin->eEnd!=TK_UNBOUNDED ){
			if( regEnd ) addr = sqlVdbeAddOp3(v, OP_IfPos, regEnd, 0, 1);
			windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 0);
			windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);
			if( regEnd ) sqlVdbeJumpHere(v, addr);
		}
	}
	if( addrPeerJump ){
		sqlVdbeJumpHere(v, addrPeerJump);
	}
	VdbeComment((v, "End windowCodeStep.SECOND_ROW"));

	/* End of the main input loop */
	sqlVdbeJumpHere(v, addrGoto);
	if (addrShortcut > 0)
		sqlVdbeJumpHere(v, addrShortcut);
	sqlWhereEnd(pWInfo);

	/* Fall through */
	if (pMWin->pPartition) {
		addrInteger = sqlVdbeAddOp2(v, OP_Integer, 0, regFlushPart);
		sqlVdbeJumpHere(v, addrGosubFlush);
	}

	VdbeComment((v, "Begin windowCodeStep.FLUSH"));
	addrEmpty = sqlVdbeAddOp1(v, OP_Rewind, csrWrite);
	if (pMWin->eEnd == TK_PRECEDING) {
		windowCodeOp(&s, WINDOW_AGGSTEP, regEnd, 0);
		windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 0);
	} else if (pMWin->eStart == TK_FOLLOWING) {
		int addrStart;
		int addrBreak1;
		int addrBreak2;
		int addrBreak3;
		windowCodeOp(&s, WINDOW_AGGSTEP, 0, 0);
		if( pMWin->eEnd==TK_UNBOUNDED  ){
			addrStart = sqlVdbeCurrentAddr(v);
			addrBreak1 = windowCodeOp(&s, WINDOW_RETURN_ROW, regStart, 1);
			addrBreak2 = windowCodeOp(&s, WINDOW_AGGINVERSE, 0, 1);
		}else{
			assert( pMWin->eEnd==TK_FOLLOWING );
			addrStart = sqlVdbeCurrentAddr(v);
			addrBreak1 = windowCodeOp(&s, WINDOW_RETURN_ROW, regEnd, 1);
			addrBreak2 = windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 1);
		}
		sqlVdbeAddOp2(v, OP_Goto, 0, addrStart);
		sqlVdbeJumpHere(v, addrBreak2);
		addrStart = sqlVdbeCurrentAddr(v);
		addrBreak3 = windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 1);
		sqlVdbeAddOp2(v, OP_Goto, 0, addrStart);
		sqlVdbeJumpHere(v, addrBreak1);
		sqlVdbeJumpHere(v, addrBreak3);
	} else {
		int addrBreak;
		int addrStart;
		windowCodeOp(&s, WINDOW_AGGSTEP, 0, 0);
		addrStart = sqlVdbeCurrentAddr(v);
		addrBreak = windowCodeOp(&s, WINDOW_RETURN_ROW, 0, 1);
		windowCodeOp(&s, WINDOW_AGGINVERSE, regStart, 0);
		sqlVdbeAddOp2(v, OP_Goto, 0, addrStart);
		sqlVdbeJumpHere(v, addrBreak);
	}

	sqlVdbeJumpHere(v, addrEmpty);

	sqlVdbeAddOp1(v, OP_ResetSorter, s.current.csr);
	sqlVdbeAddOp2(v, OP_Bool, 1, pMWin->regFirst);
	VdbeComment((v, "End windowCodeStep.FLUSH"));
	if (pMWin->pPartition) {
		sqlVdbeChangeP1(v, addrInteger, sqlVdbeCurrentAddr(v));
		sqlVdbeAddOp1(v, OP_Return, regFlushPart);
	}
}
