/**
 * Copyright (C) Picodata LLC - All Rights Reserved
 *
 * This source code is protected under international copyright law.  All rights
 * reserved and protected by the copyright holders.
 * This file is confidential and only available to authorized individuals with
 * the permission of the copyright holders.  If you encounter this file and do
 * not have permission, please contact the copyright holders and delete this
 * file.
 */

#include "sqlInt.h"
#include "vdbe.h"
#include "vdbeInt.h"
#include "box/sql.h"
#include "box/field_def.h"

/*
 * SELECT REWRITING
 *
 * Any SELECT statement that contains one or more window functions in
 * either the select list or ORDER BY clause (the only two places window
 * functions may be used) is transformed by function sqlWindowRewrite()
 * in order to support window function processing. For example, with the
 * schema:
 *
 *   CREATE TABLE t1(a, b, c, d, e, f, g);
 *
 * the statement:
 *
 *   SELECT a+1, max(b) OVER (PARTITION BY c ORDER BY d) FROM t1 ORDER BY e;
 *
 * is transformed to:
 *
 *   SELECT a+1, max(b) OVER (PARTITION BY c ORDER BY d) FROM (
 *       SELECT a, e, c, d, b FROM t1 ORDER BY c, d
 *   ) ORDER BY e;
 *
 * The flattening optimization is disabled when processing this transformed
 * SELECT statement. This allows the implementation of the window function
 * (in this case max()) to process rows sorted in order of (c, d), which
 * makes things easier for obvious reasons. More generally:
 *
 *   * FROM, WHERE, GROUP BY and HAVING clauses are all moved to
 *     the sub-query.
 *
 *   * ORDER BY, LIMIT and OFFSET remain part of the parent query.
 *
 *   * Terminals from each of the expression trees that make up the
 *     select-list and ORDER BY expressions in the parent query are
 *     selected by the sub-query. For the purposes of the transformation,
 *     terminals are column references and aggregate functions.
 *
 * If there is more than one window function in the SELECT that uses
 * the same window declaration (the OVER bit), then a single scan may
 * be used to process more than one window function. For example:
 *
 *   SELECT max(b) OVER (PARTITION BY c ORDER BY d),
 *          min(e) OVER (PARTITION BY c ORDER BY d)
 *   FROM t1;
 *
 * is transformed in the same way as the example above. However:
 *
 *   SELECT max(b) OVER (PARTITION BY c ORDER BY d),
 *          min(e) OVER (PARTITION BY a ORDER BY b)
 *   FROM t1;
 *
 * Must be transformed to:
 *
 *   SELECT max(b) OVER (PARTITION BY c ORDER BY d) FROM (
 *       SELECT e, min(e) OVER (PARTITION BY a ORDER BY b), c, d, b FROM
 *         SELECT a, e, c, d, b FROM t1 ORDER BY a, b
 *       ) ORDER BY c, d
 *   ) ORDER BY e;
 *
 * so that both min() and max() may process rows in the order defined by
 * their respective window declarations.
 *
 * INTERFACE WITH SELECT.C
 *
 * When processing the rewritten SELECT statement, code in select.c calls
 * sqlWhereBegin() to begin iterating through the results of the
 * sub-query, which is always implemented as a co-routine. It then calls
 * sqlWindowCodeStep() to process rows and finish the scan by calling
 * sqlWhereEnd().
 *
 * sqlWindowCodeStep() generates VM code so that, for each row returned
 * by the sub-query a sub-routine (OP_Gosub) coded by select.c is invoked.
 * When the sub-routine is invoked:
 *
 *   * The results of all window-functions for the row are stored
 *     in the associated Window.regResult registers.
 *
 *   * The required terminal values are stored in the current row of
 *     temp table Window.iEphCsr.
 *
 * In some cases, depending on the window frame and the specific window
 * functions invoked, sqlWindowCodeStep() caches each entire partition
 * in a temp table before returning any rows. In other cases it does not.
 * This detail is encapsulated within this file, the code generated by
 * select.c is the same in either case.
 *
 * BUILT-IN WINDOW FUNCTIONS
 *
 * This implementation features the following built-in window functions:
 *
 *   row_number()
 *
 * Not implemented:
 *   rank()
 *   dense_rank()
 *   percent_rank()
 *   cume_dist()
 *   ntile(N)
 *   lead(expr [, offset [, default]])
 *   lag(expr [, offset [, default]])
 *   first_value(expr)
 *   last_value(expr)
 *   nth_value(expr, N)
 *
 * These are the same built-in window functions supported by Postgres.
 * Although the behaviour of aggregate window functions (functions that
 * can be used as either aggregates or window functions) allows them to
 * be implemented using an API, built-in window functions are much more
 * esoteric. Additionally, some window functions (e.g. nth_value())
 * may only be implemented by caching the entire partition in memory.
 * As such, some built-in window functions use the same API as aggregate
 * window functions and some are implemented directly using VDBE
 * instructions. Additionally, for those functions that use the API, the
 * window frame is sometimes modified before the SELECT statement is
 * rewritten. For example, regardless of the specified window frame, the
 * row_number() function always uses:
 *
 *   ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
 *
 * See sqlWindowUpdate() for details.
 *
 * As well as some of the built-in window functions, aggregate window
 * functions min() and max() are implemented using VDBE instructions if
 * the start of the window frame is declared as anything other than
 * UNBOUNDED PRECEDING.
 */

/*
 * This function is called immediately after resolving the function name
 * for a window function within a SELECT statement. Argument pList is a
 * linked list of WINDOW definitions for the current SELECT statement.
 * Argument pFunc is the function definition just resolved and pWin
 * is the Window object representing the associated OVER clause. This
 * function updates the contents of pWin as follows:
 *
 *   * If the OVER clause referred to a named window (as in "max(x) OVER win"),
 *     search list pList for a matching WINDOW definition, and update pWin
 *     accordingly. If no such WINDOW clause can be found, leave an error
 *     in pParse.
 *
 *   * If the function is a built-in window function that requires the
 *     window to be coerced (see "BUILT-IN WINDOW FUNCTIONS" at the top
 *     of this file), pWin is updated here.
 */
void
sqlWindowUpdate(
	Parse *pParse,
	Window *pList,		/* List of named windows for this SELECT */
	Window *pWin,		/* Window frame to update */
	struct func *pFunc)	/* Window function definition */
{
	if (pWin->zName && pWin->eType == 0) {
		Window *p;
		for (p = pList; p; p = p->pNextWin) {
			if (sqlStrICmp(p->zName, pWin->zName) == 0)
				break;
		}
		if (p == 0) {
			const char *err_msg = tt_sprintf("no such window: %s",
							 pWin->zName);
			diag_set(ClientError, ER_SQL_PARSER_GENERIC, err_msg);
			pParse->is_aborted = true;
			return;
		}
		pWin->pPartition = sql_expr_list_dup(p->pPartition, 0);
		pWin->pOrderBy = sql_expr_list_dup(p->pOrderBy, 0);
		pWin->pStart = sqlExprDup(p->pStart, 0);
		pWin->pEnd = sqlExprDup(p->pEnd, 0);
		pWin->eStart = p->eStart;
		pWin->eEnd = p->eEnd;
		pWin->eType = p->eType;
	}
	uint32_t flags = sql_func_flags(pFunc->def->name);
	if ((flags & SQL_FUNC_WINDOW) != 0) {
		if (pWin->pFilter) {
			const char *err_msg;
			err_msg = tt_sprintf("%s %s",
					     "FILTER clause may only be used",
					     "with aggregate window functions");
			diag_set(ClientError, ER_SQL_PARSER_GENERIC, err_msg);
			pParse->is_aborted = true;
		} else {
			/* The only supported window function is row_number() */
			pWin->pStart = 0;
			pWin->pEnd = 0;
			pWin->eType = TK_ROWS;
			pWin->eStart = TK_UNBOUNDED;
			pWin->eEnd = TK_CURRENT;
		}
	}
	pWin->pFunc = pFunc;
}

/*
 * Context object passed through sqlWalkExprList() to
 * selectWindowRewriteExprCb() by selectWindowRewriteEList().
 */
struct WindowRewrite {
	/* Windows for this traversal */
	Window *pWin;
	/* Rewritten expression list */
	ExprList *pSub;
};

/*
 * Callback function used by selectWindowRewriteEList(). If necessary,
 * this function appends to the output expression-list and updates
 * expression (*ppExpr) in place.
 */
static int
selectWindowRewriteExprCb(Walker *pWalker, Expr *pExpr)
{
	struct WindowRewrite *p = pWalker->u.pRewrite;

	enum field_type eType = sql_expr_type(pExpr);
	ExprClearProperty(pExpr, EP_Resolved);

	switch (pExpr->op) {
	case TK_FUNCTION:
		if (!ExprHasProperty(pExpr, EP_WinFunc)) {
			break;
		}
		Window *pWin;
		for (pWin = p->pWin; pWin; pWin = pWin->pNextWin) {
			if (pExpr->y.pWin == pWin) {
				assert(pWin->pOwner == pExpr);
				return WRC_Prune;
			}
		}
	FALLTHROUGH;
	case TK_AGG_FUNCTION:
	case TK_COLUMN_REF: {
		Expr *pDup = sqlExprDup(pExpr, 0);
		p->pSub = sql_expr_list_append(p->pSub, pDup);
		if (p->pSub) {
			assert(ExprHasProperty(pExpr, EP_Static) == 0);
			ExprSetProperty(pExpr, EP_Static);
			sql_expr_delete(pExpr);
			ExprClearProperty(pExpr, EP_Static);
			memset(pExpr, 0, sizeof(Expr));

			pExpr->op = TK_WIN_COLUMN;
			pExpr->type = eType;
			pExpr->iColumn = p->pSub->nExpr - 1;
			pExpr->iTable = p->pWin->iEphCsr;
		}

		break;
	}
	default: /* no-op */
		break;
	}
	return WRC_Continue;
}

static int
selectWindowRewriteSelectCb(Walker *pWalker, Select *pSelect)
{
	(void)pWalker;
	(void)pSelect;
	return WRC_Prune;
}

/*
 * Iterate through each expression in expression-list pEList. For each:
 *
 *   * TK_COLUMN_REF,
 *   * aggregate function, or
 *   * window function with a Window object that is not a member of the
 *     linked list passed as the second argument (pWin)
 *
 * Append the node to output expression-list (*ppSub). And replace it
 * with a TK_COLUMN_REF that reads the (N-1)th element of table
 * pWin->iEphCsr, where N is the number of elements in (*ppSub) after
 * appending the new one.
 */
static void
selectWindowRewriteEList(
	Parse *pParse,
	Window *pWin,
	ExprList *pEList,	/* Rewrite expressions in this list */
	ExprList **ppSub)	/* IN/OUT: Sub-select expression-list */
{
	Walker sWalker;
	struct WindowRewrite sRewrite;

	memset(&sWalker, 0, sizeof(Walker));
	memset(&sRewrite, 0, sizeof(struct WindowRewrite));

	sRewrite.pSub = *ppSub;
	sRewrite.pWin = pWin;

	sWalker.pParse = pParse;
	sWalker.xExprCallback = selectWindowRewriteExprCb;
	sWalker.xSelectCallback = selectWindowRewriteSelectCb;
	sWalker.u.pRewrite = &sRewrite;

	(void)sqlWalkExprList(&sWalker, pEList);

	*ppSub = sRewrite.pSub;
}

/*
 * Append a copy of each expression in expression-list pAppend to
 * expression list pList. Return a pointer to the result list.
 */
static ExprList *
exprListAppendList(
	ExprList *pList,	/* List to which to append. Might be NULL */
	ExprList *pAppend)	/* List of values to append. Might be NULL */
{
	if (pAppend) {
		int i;
		int nInit = pList ? pList->nExpr : 0;
		for (i = 0; i < pAppend->nExpr; i++) {
			Expr *pDup = sqlExprDup(pAppend->a[i].pExpr, 0);
			pList = sql_expr_list_append(pList, pDup);
			if (pList)
				pList->a[nInit + i].sort_order =
				pAppend->a[i].sort_order;
		}
	}
	return pList;
}

/*
 * If the SELECT statement passed as the second argument does not invoke
 * any SQL window functions, this function is a no-op. Otherwise, it
 * rewrites the SELECT statement so that window function xStep functions
 * are invoked in the correct order as described under "SELECT REWRITING"
 * at the top of this file.
 */
int
sqlWindowRewrite(Parse *pParse, Select *p)
{
	int rc = 0;
	if (p->pWin && p->pPrior == 0) {
		Vdbe *v = sqlGetVdbe(pParse);
		/* The subquery */
		Select *pSub = 0;
		SrcList *pSrc = p->pSrc;
		Expr *pWhere = p->pWhere;
		ExprList *pGroupBy = p->pGroupBy;
		Expr *pHaving = p->pHaving;
		ExprList *pSort = 0;

		/* Expression list for sub-query */
		ExprList *pSublist = 0;
		/* Master window object */
		Window *pMWin = p->pWin;
		/* Window object iterator */
		Window *pWin;

		p->pSrc = 0;
		p->pWhere = 0;
		p->pGroupBy = 0;
		p->pHaving = 0;

		/*
		 * Create the ORDER BY clause for the sub-select.
		 * This is the concatenation
		 * of the window PARTITION and ORDER BY clauses.
		 * Then, if this makes it redundant,
		 * remove the ORDER BY from the parent SELECT.
		 */
		pSort = sql_expr_list_dup(pMWin->pPartition, 0);
		pSort = exprListAppendList(pSort, pMWin->pOrderBy);
		if (pSort && p->pOrderBy) {
			if (sqlExprListCompare(pSort, p->pOrderBy, -1) == 0) {
				sql_expr_list_delete(p->pOrderBy);
				p->pOrderBy = 0;
			}
		}

		/*
		 * Assign a cursor number
		 * for the ephemeral table used to buffer rows.
		 * The OpenTEphemeral instruction is coded later,
		 * after it is known how many columns the table will have.
		 */
		pMWin->iEphCsr = pParse->nTab++;
		pMWin->regEph = ++pParse->nMem;

		selectWindowRewriteEList(pParse, pMWin, p->pEList, &pSublist);
		selectWindowRewriteEList(pParse, pMWin, p->pOrderBy, &pSublist);
		pMWin->nBufferCol = (pSublist ? pSublist->nExpr : 0);

		/*
		 * Append the PARTITION BY and ORDER BY expressions to the
		 * sub-select expression list.
		 * They are required to figure out where
		 * boundaries for partitions and sets of peer rows lie.
		 */
		pSublist = exprListAppendList(pSublist, pMWin->pPartition);
		pSublist = exprListAppendList(pSublist, pMWin->pOrderBy);

		/*
		 * Append the arguments passed to each window function to the
		 * sub-select expression list.
		 * Also allocate two registers for each
		 * window function - one for the accumulator,
		 * another for interim results.
		 */
		for (pWin = pMWin; pWin; pWin = pWin->pNextWin) {
			pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);
			pSublist = exprListAppendList(pSublist,
						      pWin->pOwner->x.pList);
			if (pWin->pFilter) {
				Expr *pFilter = sqlExprDup(pWin->pFilter, 0);
				pSublist = sql_expr_list_append(pSublist,
								pFilter);
			}
			pWin->regAccum = ++pParse->nMem;
			pWin->regResult = ++pParse->nMem;
			sqlVdbeAddOp2(v, OP_Null, 0, pWin->regAccum);
		}

		/* If there is no ORDER BY or PARTITION BY clause,
		 * and the window function accepts zero arguments,
		 * and there are no other columns selected
		 * (e.g. "SELECT row_number() OVER () FROM t1"), it is possible
		 * that pSublist is still NULL here.
		 * Add a constant expression here to
		 * keep everything legal in this case.
		 */
		if (pSublist == 0) {
			Token t;
			sqlTokenInit(&t, "0");
			pSublist = sql_expr_list_append(
					0,
					sql_expr_new(TK_INTEGER, &t));
		}

		pSub = sqlSelectNew(pParse, pSublist, pSrc, pWhere, pGroupBy,
				    pHaving, pSort, 0, 0, 0);
		p->pSrc = sql_src_list_append(0, 0);
		p->pSrc->a[0].pSelect = pSub;
		sqlSrcListAssignCursors(pParse, p->pSrc);
		sqlExpandSubquery(pParse, &p->pSrc->a[0]);
		pSub->selFlags |= SF_Expanded;
		p->selFlags &= ~SF_Aggregate;
		sqlSelectPrep(pParse, pSub, 0);

		/*
		 * Ephemeral table requires PK, so append a rowid to the end
		 * of the list.
		 * Rowid acts as a primary key for the ephemeral table.
		 */
		struct sql_space_info *info;
		info = sql_space_info_new_from_expr_list(pParse, pSublist,
							 true);
		info->part_count = 1;
		info->sort_orders[0] = SORT_ORDER_ASC;
		info->parts[0] = pSublist->nExpr;

		sqlVdbeAddOp4(v, OP_OpenTEphemeral, pMWin->regEph,
			      0, 0, (char *)info, P4_DYNAMIC);
		sqlVdbeAddOp3(v, OP_IteratorOpen, pMWin->iEphCsr,
			      0, pMWin->regEph);
	}

	return rc;
}

/*
 * Free the Window object passed as the second argument.
 */
void
sqlWindowDelete(Window *p)
{
	if (p) {
		sql_expr_delete(p->pFilter);
		sql_expr_list_delete(p->pPartition);
		sql_expr_list_delete(p->pOrderBy);
		sql_expr_delete(p->pEnd);
		sql_expr_delete(p->pStart);
		sql_xfree(p->zName);
		sql_xfree(p);
	}
}

/*
 * Free the linked list of Window objects starting at the second argument.
 */
void
sqlWindowListDelete(Window *p)
{
	while (p) {
		Window *pNext = p->pNextWin;
		sqlWindowDelete(p);
		p = pNext;
	}
}

/*
 * The argument expression is an PRECEDING or FOLLOWING offset.  The
 * value should be a non-negative integer.  If the value is not a
 * constant, change it to NULL.  The fact that it is then a non-negative
 * integer will be caught later.  But it is important not to leave
 * variable values in the expression tree.
 */
static Expr *
sqlWindowOffsetExpr(Expr *pExpr)
{
	if (sqlExprIsConstant(pExpr) == 0) {
		sql_expr_delete(pExpr);
		pExpr = sql_expr_new(TK_NULL, NULL);
	}
	return pExpr;
}

/*
 * Allocate and return a new Window object.
 */
Window *
sqlWindowAlloc(
	Parse *pParse, int eType,
	int eStart, Expr *pStart,
	int eEnd, Expr *pEnd)
{
	/* Parser assures the following: */
	assert(eType == 0 || eType == TK_RANGE || eType == TK_ROWS);
	assert(eStart == TK_CURRENT || eStart == TK_PRECEDING ||
	       eStart == TK_UNBOUNDED || eStart == TK_FOLLOWING);
	assert(eEnd == TK_CURRENT || eEnd == TK_FOLLOWING ||
	       eEnd == TK_UNBOUNDED || eEnd == TK_PRECEDING);
	assert((eStart == TK_PRECEDING || eStart == TK_FOLLOWING)
	       == (pStart != 0));
	assert((eEnd == TK_FOLLOWING || eEnd == TK_PRECEDING)
	       == (pEnd != 0));

	if (eType == TK_RANGE && (pStart != 0 || pEnd != 0)) {
		diag_set(ClientError, ER_SQL_PARSER_GENERIC,
			 "RANGE must use only UNBOUNDED or CURRENT ROW");
		pParse->is_aborted = true;
		return NULL;
	}

	/* Additionally, the starting boundary type may not occur earlier
	 * in the following list than the ending boundary type:
	 *
	 *   UNBOUNDED PRECEDING
	 *   <expr> PRECEDING
	 *   CURRENT ROW
	 *   <expr> FOLLOWING
	 *   UNBOUNDED FOLLOWING
	 *
	 * The parser ensures that "UNBOUNDED PRECEDING" cannot be used as an
	 * ending boundary, and than "UNBOUNDED FOLLOWING" cannot be used as
	 * a starting frame boundary.
	 */
	if ((eType == TK_RANGE && (pStart || pEnd)) ||
	    (eStart == TK_CURRENT && eEnd == TK_PRECEDING) ||
	    (eStart == TK_FOLLOWING && (eEnd == TK_PRECEDING ||
					eEnd == TK_CURRENT))) {
		diag_set(ClientError, ER_SQL_PARSER_GENERIC,
			 "unsupported window-frame type");
		pParse->is_aborted = true;
		return NULL;
	}

	Window *pWin = (Window *)sql_xmalloc0(sizeof(Window));
	pWin->eType = eType;
	pWin->eStart = eStart;
	pWin->eEnd = eEnd;
	pWin->pEnd = sqlWindowOffsetExpr(pEnd);
	pWin->pStart = sqlWindowOffsetExpr(pStart);
	return pWin;
}

/*
 * Attach window object pWin to expression p.
 */
void
sqlWindowAttach(Parse *pParse, Expr *p, Window *pWin)
{
	if (p) {
		assert(p->op == TK_FUNCTION);
		if (pWin != NULL) {
			p->y.pWin = pWin;
			ExprSetProperty(p, EP_WinFunc);
			pWin->pOwner = p;
			if (p->flags & EP_Distinct) {
				diag_set(ClientError, ER_SQL_PARSER_GENERIC,
					 "DISTINCT is not supported "
					 "for window functions");
				pParse->is_aborted = true;
			}
		}
	} else {
		sqlWindowDelete(pWin);
	}
}

/*
 * Return 0 if the two window objects are identical, or non-zero otherwise.
 * Identical window objects can be processed in a single scan.
 */
int
sqlWindowCompare(Window *p1, Window *p2)
{
	if (p1->eType != p2->eType)
		return 1;
	if (p1->eStart != p2->eStart)
		return 1;
	if (p1->eEnd != p2->eEnd)
		return 1;
	if (sqlExprCompare(p1->pStart, p2->pStart, -1))
		return 1;
	if (sqlExprCompare(p1->pEnd, p2->pEnd, -1))
		return 1;
	if (sqlExprListCompare(p1->pPartition, p2->pPartition, -1))
		return 1;
	if (sqlExprListCompare(p1->pOrderBy, p2->pOrderBy, -1))
		return 1;
	return 0;
}

/*
 * This is called by code in select.c before it calls sqlWhereBegin()
 * to begin iterating through the sub-query results. It is used to allocate
 * and initialize registers and cursors used by sqlWindowCodeStep().
 */
void
sqlWindowCodeInit(Parse *pParse, Window *pMWin)
{
	Window *pWin;
	Vdbe *v = sqlGetVdbe(pParse);
	int nPart = (pMWin->pPartition ? pMWin->pPartition->nExpr : 0);
	nPart += (pMWin->pOrderBy ? pMWin->pOrderBy->nExpr : 0);
	if (nPart) {
		pMWin->regPart = pParse->nMem + 1;
		pParse->nMem += nPart;
		sqlVdbeAddOp3(v, OP_Null, 0, pMWin->regPart,
			      pMWin->regPart + nPart - 1);
	}

	for (pWin = pMWin; pWin; pWin = pWin->pNextWin) {
		struct func *p = pWin->pFunc;
		uint32_t flags = sql_func_flags(p->def->name);
		bool is_minmax = (flags & SQL_FUNC_MIN) ||
				 (flags & SQL_FUNC_MAX);
		if (is_minmax && pWin->eStart != TK_UNBOUNDED) {
			/* The inline versions of min() and max()
			 * require a single ephemeral table and 3 registers.
			 * The registers are used as follows:
			 *
			 *	regApp+0: slot to copy min()/max()
			 *	argument to for MakeRecord
			 *	regApp+1: integer value used
			 *	to ensure keys are unique
			 *	regApp+2: output of MakeRecord
			 */
			ExprList *pList = pWin->pOwner->x.pList;
			/*
			 * Ephemeral table requires PK,
			 * so append a rowid to the end
			 * of the list. Rowid acts as a primary key
			 * for the ephemeral table.
			 */
			struct sql_space_info *info;
			info = sql_space_info_new_from_expr_list(pParse,
								 pList, true);
			pWin->csrApp = pParse->nTab++;
			pWin->regAppCsr = pParse->nMem + 1;
			++pParse->nMem;
			pWin->regApp = pParse->nMem + 1;
			pParse->nMem += 3;

			sqlVdbeAddOp4(v, OP_OpenTEphemeral,
				      pWin->regAppCsr, 0, 0,
				      (char *)info, P4_DYNAMIC);
			sqlVdbeAddOp3(v, OP_IteratorOpen, pWin->csrApp, 0,
				      pWin->regAppCsr);
			sqlVdbeAddOp2(v, OP_Integer, 0, pWin->regApp + 1);
		}
	}
}

/*
 * A "PRECEDING <expr>" (bEnd==0) or "FOLLOWING <expr>" (bEnd==1) has just
 * been evaluated and the result left in register reg. This function generates
 * VM code to check that the value is a non-negative integer and throws
 * an exception if it is not.
 */
static void
windowCheckFrameOffset(Parse *pParse, int reg, int bEnd)
{
	static const char *const azErr[] = {
		"frame starting offset must be a non-negative integer",
		"frame ending offset must be a non-negative integer"
	};
	Vdbe *v = sqlGetVdbe(pParse);
	int regZero = sqlGetTempReg(pParse);
	sqlVdbeAddOp2(v, OP_Integer, 0, regZero);
	sqlVdbeAddOp2(v, OP_MustBeInt, reg, sqlVdbeCurrentAddr(v) + 2);
	sqlVdbeAddOp3(v, OP_Ge, regZero, sqlVdbeCurrentAddr(v) + 2, reg);
	sqlVdbeAddOp2(v, OP_Halt, -1, ON_CONFLICT_ACTION_ABORT);
	sqlVdbeAppendP4(v, (void *)azErr[bEnd], P4_STATIC);
	sqlReleaseTempReg(pParse, regZero);
}

/*
 * Return the number of arguments passed to the window-function associated
 * with the object passed as the only argument to this function.
 */
static int
windowArgCount(Window *pWin)
{
	ExprList *pList = pWin->pOwner->x.pList;
	return pList ? pList->nExpr : 0;
}

/*
 * Generate VM code to invoke either xStep() (if bInverse is 0) or
 * xInverse (if bInverse is non-zero) for each window function in the
 * linked list starting at pMWin. Or, for built-in window functions
 * that do not use the standard function API, generate the required
 * inline VM code.
 *
 * If argument csr is greater than or equal to 0, then argument reg is
 * the first register in an array of registers guaranteed to be large
 * enough to hold the array of arguments for each function. In this case
 * the arguments are extracted from the current row of csr into the
 * array of registers before invoking OP_AggStep.
 *
 * Or, if csr is less than zero, then the array of registers at reg is
 * already populated with all columns from the current row of the sub-query.
 *
 * If argument regPartSize is non-zero, then it is a register containing the
 * number of rows in the current partition.
 */
static void
windowAggStep(
	Parse *pParse,
	Window *pMWin,		/* Linked list of window functions */
	int csr,		/* Read arguments from this cursor */
	int bInverse,		/* True to invoke xInverse instead of xStep */
	int reg,		/* Array of registers */
	int regPartSize)	/* Register containing size of partition */
{
	(void)regPartSize;
	Vdbe *v = sqlGetVdbe(pParse);
	Window *pWin;
	int regHit = 0;
	for (pWin = pMWin; pWin; pWin = pWin->pNextWin) {
		uint32_t flags = sql_func_flags(pWin->pFunc->def->name);
		int regArg;
		int nArg = windowArgCount(pWin);

		if (csr >= 0) {
			int i;
			for (i = 0; i < nArg; i++) {
				sqlVdbeAddOp3(v, OP_Column, csr,
					      pWin->iArgCol + i, reg + i);
			}
			regArg = reg;
		} else {
			regArg = reg + pWin->iArgCol;
		}

		bool is_minmax = (flags & SQL_FUNC_MIN) ||
				 (flags & SQL_FUNC_MAX);
		if (is_minmax && pWin->eStart != TK_UNBOUNDED) {
			if (bInverse == 0) {
				sqlVdbeAddOp2(v, OP_AddImm,
					      pWin->regApp + 1, 1);
				sqlVdbeAddOp2(v, OP_SCopy,
					      regArg, pWin->regApp);
				sqlVdbeAddOp3(v, OP_MakeRecord, pWin->regApp, 2,
					      pWin->regApp + 2);
				sqlVdbeChangeP5(v, 1);
				sqlVdbeAddOp2(v, OP_IdxInsert, pWin->regApp + 2,
					      pWin->regAppCsr);
			} else {
				sqlVdbeAddOp4Int(v, OP_SeekGE, pWin->csrApp, 0,
						 regArg, 1);
				sqlVdbeAddOp1(v, OP_Delete, pWin->csrApp);
				sqlVdbeJumpHere(v, sqlVdbeCurrentAddr(v) - 2);
			}
		} else {
			int addrIf = 0;
			struct coll *coll = NULL;
			if (pWin->pFilter) {
				int regTmp;
				assert(nArg == pWin->pOwner->x.pList->nExpr);
				if (csr > 0) {
					regTmp = sqlGetTempReg(pParse);
					sqlVdbeAddOp3(v, OP_Column, csr,
						      pWin->iArgCol + nArg,
						      regTmp);
				} else {
					regTmp = regArg + nArg;
				}
				addrIf = sqlVdbeAddOp3(v, OP_IfNot,
						       regTmp, 0, 1);
				if (csr > 0) {
					sqlReleaseTempReg(pParse, regTmp);
				}
			}
			if (flags &SQL_FUNC_NEEDCOLL) {
				bool unused;
				uint32_t id;
				Expr *pExpr = pWin->pOwner->x.pList->a[0].pExpr;
				if (sql_expr_coll(pParse, pExpr, &unused, &id,
						  &coll) != 0) {
					coll = NULL;
				}
				if (regHit == 0)
					regHit = ++pParse->nMem;
				sqlVdbeAddOp1(v, OP_SkipLoad, regHit);
			}
			struct sql_context *ctx = sql_context_new(pWin->pFunc,
								  coll);
			if (bInverse)
				ctx->funcFlag |= SQL_CTX_INVERSE;
			sqlVdbeAddOp3(v, OP_AggStep, nArg, regArg,
				      pWin->regAccum);
			sqlVdbeAppendP4(v, ctx, P4_FUNCCTX);
			if (addrIf)
				sqlVdbeJumpHere(v, addrIf);
		}
	}
}

/*
 * Generate VM code to invoke either xValue() (bFinal==0) or xFinalize()
 * (bFinal==1) for each window function in the linked list starting at
 * pMWin. Or, for built-in window-functions that do not use the standard
 * API, generate the equivalent VM code.
 */
static void
windowAggFinal(Parse *pParse, Window *pMWin, int bFinal)
{
	Vdbe *v = sqlGetVdbe(pParse);
	Window *pWin;

	for (pWin = pMWin; pWin; pWin = pWin->pNextWin) {
		uint32_t flags = sql_func_flags(pWin->pFunc->def->name);
		bool is_minmax = (flags &SQL_FUNC_MIN) ||
				 (flags &SQL_FUNC_MAX);
		if (is_minmax && pWin->eStart != TK_UNBOUNDED) {
			sqlVdbeAddOp2(v, OP_Null, 0, pWin->regResult);
			if (flags &SQL_FUNC_MIN)
				sqlVdbeAddOp3(v, OP_Rewind, pWin->csrApp, 0, 0);
			else
				sqlVdbeAddOp3(v, OP_Last, pWin->csrApp, 0, 0);
			sqlVdbeAddOp3(v, OP_Column, pWin->csrApp, 0,
				      pWin->regResult);
			sqlVdbeJumpHere(v, sqlVdbeCurrentAddr(v) - 2);
			if (bFinal) {
				sqlVdbeAddOp1(v, OP_ResetSorter, pWin->csrApp);
			}
		} else if (pWin->regApp) {
		} else {
			if (bFinal == 0) {
				sqlVdbeAddOp2(v, OP_Null, 0, pWin->regResult);
			}
			sqlVdbeAddOp1(v, OP_AggFinal, pWin->regAccum);
			sqlVdbeAppendP4(v, pWin->pFunc, P4_FUNC);
			if (bFinal) {
				sqlVdbeAddOp2(v, OP_Copy, pWin->regAccum,
					      pWin->regResult);
				sqlVdbeAddOp2(v, OP_Null, 0, pWin->regAccum);
			} else {
				sqlVdbeChangeP3(v, -1, pWin->regResult);
			}
		}
	}
}

/*
 * This function generates VM code to invoke the sub-routine at address
 * lblFlushPart once for each partition with the entire partition cached in
 * the Window.regEph temp table.
 */
static void
windowPartitionCache(
	Parse *pParse,
	Select *p,		/* The rewritten SELECT statement */
	WhereInfo *pWInfo,	/* WhereInfo to call WhereEnd() on */
	int regFlushPart,	/* Register to use with Gosub lblFlushPart */
	int lblFlushPart,	/* Subroutine to Gosub to */
	int *pRegSize)		/* OUT: Register containing partition size */
{
	Window *pMWin = p->pWin;
	Vdbe *v = sqlGetVdbe(pParse);
	int iSubCsr = p->pSrc->a[0].iCursor;
	int nSub = p->pSrc->a[0].space->def->field_count;
	int k;

	int reg = pParse->nMem + 1;
	int regRowid = reg + nSub;
	int regRecord = regRowid + 1;

	*pRegSize = regRowid;
	pParse->nMem += nSub + 2;

	/*
	 * Martial the row returned by the sub-select into an array of
	 * registers. To make each record unique, a new rowid is generated
	 * and appended as the last column.
	 */
	for (k = 0; k < nSub; k++) {
		sqlVdbeAddOp3(v, OP_Column, iSubCsr, k, reg + k);
	}
	sqlVdbeAddOp2(v, OP_NextIdEphemeral, pMWin->regEph, regRowid);
	sqlVdbeAddOp3(v, OP_MakeRecord, reg, nSub + 1, regRecord);
	sqlVdbeChangeP5(v, 1);

	/*
	 * Check if this is the start of a new partition. If so, call the
	 * flush_partition sub-routine.
	 */
	if (pMWin->pPartition) {
		int addr;
		struct sql_key_info *key_info;
		ExprList *pPart = pMWin->pPartition;
		int nPart = pPart->nExpr;
		int regNewPart = reg + pMWin->nBufferCol;
		key_info = sql_expr_list_to_key_info(pParse, pPart, 0);
		addr = sqlVdbeAddOp3(v, OP_Compare, regNewPart,
				     pMWin->regPart, nPart);
		sqlVdbeAppendP4(v, (void *)key_info, P4_KEYINFO);
		sqlVdbeAddOp3(v, OP_Jump, addr + 2, addr + 4, addr + 2);
		sqlVdbeAddOp3(v, OP_Copy, regNewPart,
			      pMWin->regPart, nPart - 1);
		sqlVdbeAddOp2(v, OP_Gosub, regFlushPart, lblFlushPart);
	}

	/* Buffer the current row in the ephemeral table. */
	sqlVdbeAddOp2(v, OP_IdxInsert, regRecord, pMWin->regEph);

	/* End of the input loop */
	sqlWhereEnd(pWInfo);

	/* Invoke "flush_partition" to deal with the final (or only) partition*/
	sqlVdbeAddOp2(v, OP_Gosub, regFlushPart, lblFlushPart);
}

/*
 * Invoke the sub-routine at regGosub (generated by code in select.c) to
 * return the current row of Window.iEphCsr. If all window functions are
 * aggregate window functions that use the standard API, a single
 * OP_Gosub instruction is all that this routine generates.
 */
static void
windowReturnOneRow(
	Parse *pParse,
	Window *pMWin,
	int regGosub,
	int addrGosub)
{
	(void)pMWin;
	Vdbe *v = sqlGetVdbe(pParse);
	sqlVdbeAddOp2(v, OP_Gosub, regGosub, addrGosub);
}

/*
 * Invoke the code generated by windowReturnOneRow() and, optionally, the
 * xInverse() function for each window function, for one or more rows
 * from the Window.iEphCsr temp table. This routine generates VM code
 * similar to:
 *
 *	 while( regCtr>0 ){
 *		 regCtr--;
 *		 windowReturnOneRow()
 *		 if( bInverse ){
 *			 AggStep (xInverse)
 *		 }
 *		 Next (Window.iEphCsr)
 *	 }
 */
static void
windowReturnRows(
	Parse *pParse,
	Window *pMWin,	/* List of window functions */
	int regCtr,	/* Register containing number of rows */
	int regGosub,	/* Register for Gosub addrGosub */
	int addrGosub,	/* Address of sub-routine for ReturnOneRow */
	int regInvArg,	/* Array of registers for xInverse args */
	int regInvSize) /* Register containing size of partition */
{
	int addr;
	Vdbe *v = sqlGetVdbe(pParse);
	windowAggFinal(pParse, pMWin, 0);
	addr = sqlVdbeAddOp3(v, OP_IfPos, regCtr,
			     sqlVdbeCurrentAddr(v) + 2, 1);
	sqlVdbeAddOp2(v, OP_Goto, 0, 0);
	windowReturnOneRow(pParse, pMWin, regGosub, addrGosub);
	if (regInvArg) {
		windowAggStep(pParse, pMWin, pMWin->iEphCsr,
			      1, regInvArg, regInvSize);
	}
	sqlVdbeAddOp2(v, OP_Next, pMWin->iEphCsr, addr);
	sqlVdbeJumpHere(v, addr + 1);	 /* The OP_Goto */
}

/*
 * Generate code to set the accumulator register for each window function
 * in the linked list passed as the second argument to NULL. And perform
 * any equivalent initialization required by any built-in window functions
 * in the list.
 */
static int
windowInitAccum(Parse *pParse, Window *pMWin)
{
	Vdbe *v = sqlGetVdbe(pParse);
	int regArg;
	int nArg = 0;
	Window *pWin;
	for (pWin = pMWin; pWin; pWin = pWin->pNextWin) {
		uint32_t flags = sql_func_flags(pWin->pFunc->def->name);
		sqlVdbeAddOp2(v, OP_Null, 0, pWin->regAccum);
		nArg = MAX(nArg, windowArgCount(pWin));
		bool is_minmax = (flags &SQL_FUNC_MIN) ||
				 (flags &SQL_FUNC_MAX);
		if (is_minmax && pWin->csrApp) {
			assert(pWin->eStart != TK_UNBOUNDED);
			sqlVdbeAddOp1(v, OP_ResetSorter, pWin->csrApp);
			sqlVdbeAddOp2(v, OP_Integer, 0, pWin->regApp + 1);
		}
	}
	regArg = pParse->nMem + 1;
	pParse->nMem += nArg;
	return regArg;
}

/*
 * This function does the work of sqlWindowCodeStep() for all "ROWS"
 * window frame types except for "BETWEEN UNBOUNDED PRECEDING AND CURRENT
 * ROW". Pseudo-code for each follows.
 *
 * ROWS BETWEEN <expr1> PRECEDING AND <expr2> FOLLOWING
 *
 *     ...
 *       if( new partition ){
 *         Gosub flush_partition
 *       }
 *       Insert (record in eph-table)
 *     sqlWhereEnd()
 *     Gosub flush_partition
 *
 *   flush_partition:
 *     Once {
 *       OpenDup (iEphCsr -> csrStart)
 *       OpenDup (iEphCsr -> csrEnd)
 *     }
 *     regStart = <expr1>                // PRECEDING expression
 *     regEnd = <expr2>                  // FOLLOWING expression
 *     if( regStart<0 || regEnd<0 ){ error! }
 *     Rewind (csr,csrStart,csrEnd)      // if EOF goto flush_partition_done
 *       Next(csrEnd)                    // if EOF skip aggregation step
 *       Aggstep (csrEnd)
 *       if( (regEnd--)<=0 ){
 *         AggFinal (xValue)
 *         Gosub addrGosub
 *         Next(csr)                // if EOF goto flush_partition_done
 *         if( (regStart--)<=0 ){
 *           AggStep (csrStart, xInverse)
 *           Next(csrStart)
 *         }
 *       }
 *   flush_partition_done:
 *     ResetSorter (csr)
 *     Return
 *
 * ROWS BETWEEN <expr> PRECEDING    AND CURRENT ROW
 * ROWS BETWEEN CURRENT ROW         AND <expr> FOLLOWING
 * ROWS BETWEEN UNBOUNDED PRECEDING AND <expr> FOLLOWING
 *
 *   These are similar to the above. For "CURRENT ROW", initialize the
 *   register to 0. For "UNBOUNDED PRECEDING" to infinity.
 *
 * ROWS BETWEEN <expr> PRECEDING    AND UNBOUNDED FOLLOWING
 * ROWS BETWEEN CURRENT ROW         AND UNBOUNDED FOLLOWING
 *
 *     Rewind (csr,csrStart,csrEnd)    // if EOF goto flush_partition_done
 *     while( 1 ){
 *       Next(csrEnd)                  // Exit while(1) at EOF
 *       Aggstep (csrEnd)
 *     }
 *     while( 1 ){
 *       AggFinal (xValue)
 *       Gosub addrGosub
 *       Next(csr)                     // if EOF goto flush_partition_done
 *       if( (regStart--)<=0 ){
 *         AggStep (csrStart, xInverse)
 *         Next(csrStart)
 *       }
 *     }
 *
 *   For the "CURRENT ROW AND UNBOUNDED FOLLOWING" case, the final if()
 *   condition is always true (as if regStart were initialized to 0).
 *
 * RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
 *
 *   This is the only RANGE case handled by this routine. It modifies the
 *   second while( 1 ) loop in "ROWS BETWEEN CURRENT ... UNBOUNDED..." to
 *   be:
 *
 *     while( 1 ){
 *       AggFinal (xValue)
 *       while( 1 ){
 *         regPeer++
 *         Gosub addrGosub
 *         Next(csr)                     // if EOF goto flush_partition_done
 *         if( new peer ) break;
 *       }
 *       while( (regPeer--)>0 ){
 *         AggStep (csrStart, xInverse)
 *         Next(csrStart)
 *       }
 *     }
 *
 * ROWS BETWEEN <expr> FOLLOWING    AND <expr> FOLLOWING
 *
 *   regEnd = regEnd - regStart
 *   Rewind (csr,csrStart,csrEnd)   // if EOF goto flush_partition_done
 *     Aggstep (csrEnd)
 *     Next(csrEnd)                 // if EOF pass-through
 *     if( (regEnd--)<=0 ){
 *       if( (regStart--)<=0 ){
 *         AggFinal (xValue)
 *         Gosub addrGosub
 *         Next(csr)              // if EOF goto flush_partition_done
 *       }
 *       AggStep (csrStart, xInverse)
 *       Next (csrStart)
 *     }
 *
 * ROWS BETWEEN <expr> PRECEDING    AND <expr> PRECEDING
 *
 *   Replace the bit after "Rewind" in the above with:
 *
 *     if( (regEnd--)<=0 ){
 *       AggStep (csrEnd)
 *       Next (csrEnd)
 *     }
 *     AggFinal (xValue)
 *     Gosub addrGosub
 *     Next(csr)                  // if EOF goto flush_partition_done
 *     if( (regStart--)<=0 ){
 *       AggStep (csr2, xInverse)
 *       Next (csr2)
 *     }
 *
 */
static void
windowCodeRowExprStep(
	Parse *pParse,
	Select *p,
	WhereInfo *pWInfo,
	int regGosub,
	int addrGosub)
{
	Window *pMWin = p->pWin;
	Vdbe *v = sqlGetVdbe(pParse);
	int regFlushPart;	/* Register for "Gosub flush_partition" */
	int lblFlushPart;	/* Label for "Gosub flush_partition" */
	int lblFlushDone;	/* Label for "Gosub flush_partition_done" */

	int regArg;
	int addr;
	int csrStart = pParse->nTab++;
	int csrEnd = pParse->nTab++;
	int regStart;	/* Value of <expr> PRECEDING */
	int regEnd;	/* Value of <expr> FOLLOWING */
	int addrGoto;
	int addrTop;
	int addrIfPos1 = 0;
	int addrIfPos2 = 0;
	int regSize = 0;

	assert(pMWin->eStart == TK_PRECEDING ||
	       pMWin->eStart == TK_CURRENT ||
	       pMWin->eStart == TK_FOLLOWING ||
	       pMWin->eStart == TK_UNBOUNDED);
	assert(pMWin->eEnd == TK_FOLLOWING ||
	       pMWin->eEnd == TK_CURRENT ||
	       pMWin->eEnd == TK_UNBOUNDED ||
	       pMWin->eEnd == TK_PRECEDING);

	/* Allocate register and label for the "flush_partition" sub-routine. */
	regFlushPart = ++pParse->nMem;
	lblFlushPart = sqlVdbeMakeLabel(v);
	lblFlushDone = sqlVdbeMakeLabel(v);

	regStart = ++pParse->nMem;
	regEnd = ++pParse->nMem;

	windowPartitionCache(pParse, p, pWInfo, regFlushPart,
			     lblFlushPart, &regSize);

	addrGoto = sqlVdbeAddOp0(v, OP_Goto);

	/* Start of "flush_partition" */
	sqlVdbeResolveLabel(v, lblFlushPart);
	sqlVdbeAddOp2(v, OP_Once, 0, sqlVdbeCurrentAddr(v) + 3);
	sqlVdbeAddOp3(v, OP_IteratorOpen, csrStart, 0, pMWin->regEph);
	sqlVdbeChangeP5(v, OPFLAG_EPH_DUP);
	sqlVdbeAddOp3(v, OP_IteratorOpen, csrEnd, 0, pMWin->regEph);
	sqlVdbeChangeP5(v, OPFLAG_EPH_DUP);

	/* If either regStart or regEnd are not non-negative integers, throw
	 * an exception.
	 */
	if (pMWin->pStart) {
		sqlExprCode(pParse, pMWin->pStart, regStart);
		windowCheckFrameOffset(pParse, regStart, 0);
	}
	if (pMWin->pEnd) {
		sqlExprCode(pParse, pMWin->pEnd, regEnd);
		windowCheckFrameOffset(pParse, regEnd, 1);
	}

	/* If this is "ROWS <expr1> FOLLOWING AND ROWS <expr2> FOLLOWING", do:
	 *
	 *	 if( regEnd<regStart ){
	 *		 // The frame always consists of 0 rows
	 *		 regStart = regSize;
	 *	 }
	 *	 regEnd = regEnd - regStart;
	 */
	if (pMWin->pEnd && pMWin->pStart && pMWin->eStart == TK_FOLLOWING) {
		assert(pMWin->eEnd == TK_FOLLOWING);
		sqlVdbeAddOp3(v, OP_Ge, regStart,
			      sqlVdbeCurrentAddr(v) + 2, regEnd);
		sqlVdbeAddOp2(v, OP_Copy, regSize, regStart);
		sqlVdbeAddOp3(v, OP_Subtract, regStart, regEnd, regEnd);
	}

	if (pMWin->pEnd && pMWin->pStart && pMWin->eEnd == TK_PRECEDING) {
		assert(pMWin->eStart == TK_PRECEDING);
		sqlVdbeAddOp3(v, OP_Le, regStart,
			      sqlVdbeCurrentAddr(v) + 3, regEnd);
		sqlVdbeAddOp2(v, OP_Copy, regSize, regStart);
		sqlVdbeAddOp2(v, OP_Copy, regSize, regEnd);
	}

	/* Initialize the accumulator register for each window function to NULL */
	regArg = windowInitAccum(pParse, pMWin);

	sqlVdbeAddOp2(v, OP_Rewind, pMWin->iEphCsr, lblFlushDone);
	sqlVdbeAddOp2(v, OP_Rewind, csrStart, lblFlushDone);
	sqlVdbeChangeP5(v, 1);
	sqlVdbeAddOp2(v, OP_Rewind, csrEnd, lblFlushDone);
	sqlVdbeChangeP5(v, 1);

	/* Invoke AggStep function for each window function using the row that
	 * csrEnd currently points to. Or, if csrEnd is already at EOF,
	 * do nothing.
	 */
	addrTop = sqlVdbeCurrentAddr(v);
	if (pMWin->eEnd == TK_PRECEDING) {
		addrIfPos1 = sqlVdbeAddOp3(v, OP_IfPos, regEnd, 0, 1);
	}
	sqlVdbeAddOp2(v, OP_Next, csrEnd, sqlVdbeCurrentAddr(v) + 2);
	addr = sqlVdbeAddOp0(v, OP_Goto);
	windowAggStep(pParse, pMWin, csrEnd, 0, regArg, regSize);
	if (pMWin->eEnd == TK_UNBOUNDED) {
		sqlVdbeAddOp2(v, OP_Goto, 0, addrTop);
		sqlVdbeJumpHere(v, addr);
		addrTop = sqlVdbeCurrentAddr(v);
	} else {
		sqlVdbeJumpHere(v, addr);
		if (pMWin->eEnd == TK_PRECEDING) {
			sqlVdbeJumpHere(v, addrIfPos1);
		}
	}

	if (pMWin->eEnd == TK_FOLLOWING) {
		addrIfPos1 = sqlVdbeAddOp3(v, OP_IfPos, regEnd, 0, 1);
	}
	if (pMWin->eStart == TK_FOLLOWING) {
		addrIfPos2 = sqlVdbeAddOp3(v, OP_IfPos, regStart, 0, 1);
	}
	windowAggFinal(pParse, pMWin, 0);
	windowReturnOneRow(pParse, pMWin, regGosub, addrGosub);
	sqlVdbeAddOp2(v, OP_Next, pMWin->iEphCsr, sqlVdbeCurrentAddr(v) + 2);
	sqlVdbeAddOp2(v, OP_Goto, 0, lblFlushDone);
	if (pMWin->eStart == TK_FOLLOWING) {
		sqlVdbeJumpHere(v, addrIfPos2);
	}

	if (pMWin->eStart == TK_CURRENT ||
	    pMWin->eStart == TK_PRECEDING ||
	    pMWin->eStart == TK_FOLLOWING) {
		int lblSkipInverse = sqlVdbeMakeLabel(v);
		if (pMWin->eStart == TK_PRECEDING) {
			sqlVdbeAddOp3(v, OP_IfPos, regStart, lblSkipInverse, 1);
		}
		if (pMWin->eStart == TK_FOLLOWING) {
			sqlVdbeAddOp2(v, OP_Next, csrStart,
				      sqlVdbeCurrentAddr(v) + 2);
			sqlVdbeAddOp2(v, OP_Goto, 0, lblSkipInverse);
		} else {
			sqlVdbeAddOp2(v, OP_Next, csrStart,
				      sqlVdbeCurrentAddr(v) + 1);
		}
		windowAggStep(pParse, pMWin, csrStart, 1, regArg, regSize);
		sqlVdbeResolveLabel(v, lblSkipInverse);
	}
	if (pMWin->eEnd == TK_FOLLOWING) {
		sqlVdbeJumpHere(v, addrIfPos1);
	}
	sqlVdbeAddOp2(v, OP_Goto, 0, addrTop);

	/* flush_partition_done: */
	sqlVdbeResolveLabel(v, lblFlushDone);
	sqlVdbeAddOp1(v, OP_ResetSorter, pMWin->iEphCsr);
	sqlVdbeAddOp1(v, OP_Return, regFlushPart);

	/* Jump to here to skip over flush_partition */
	sqlVdbeJumpHere(v, addrGoto);
}

/*
 * This function does the work of sqlWindowCodeStep() for cases that
 * would normally be handled by windowCodeDefaultStep() when there are
 * one or more built-in window-functions that require the entire partition
 * to be cached in a temp table before any rows can be returned. Additionally.
 * "RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING" is always handled by
 * this function.
 *
 * Pseudo-code corresponding to the VM code generated by this function
 * for each type of window follows.
 *
 * RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
 *
 *   flush_partition:
 *     Once {
 *       OpenDup (iEphCsr -> csrLead)
 *     }
 *     Integer ctr 0
 *     foreach row (csrLead){
 *       if( new peer ){
 *         AggFinal (xValue)
 *         for(i=0; i<ctr; i++){
 *           Gosub addrGosub
 *           Next iEphCsr
 *         }
 *         Integer ctr 0
 *       }
 *       AggStep (csrLead)
 *       Incr ctr
 *     }
 *
 *     AggFinal (xFinalize)
 *     for(i=0; i<ctr; i++){
 *       Gosub addrGosub
 *       Next iEphCsr
 *     }
 *
 *     ResetSorter (csr)
 *     Return
 *
 * ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
 *
 *   As above, except that the "if( new peer )" branch is always taken.
 *
 * RANGE BETWEEN CURRENT ROW AND CURRENT ROW
 *
 *   As above, except that each of the for() loops becomes:
 *
 *         for(i=0; i<ctr; i++){
 *           Gosub addrGosub
 *           AggStep (xInverse, iEphCsr)
 *           Next iEphCsr
 *         }
 *
 * RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
 *
 *   flush_partition:
 *     Once {
 *       OpenDup (iEphCsr -> csrLead)
 *     }
 *     foreach row (csrLead) {
 *       AggStep (csrLead)
 *     }
 *     foreach row (iEphCsr) {
 *       Gosub addrGosub
 *     }
 *
 * RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
 *
 *   flush_partition:
 *     Once {
 *       OpenDup (iEphCsr -> csrLead)
 *     }
 *     foreach row (csrLead){
 *       AggStep (csrLead)
 *     }
 *     Rewind (csrLead)
 *     Integer ctr 0
 *     foreach row (csrLead){
 *       if( new peer ){
 *         AggFinal (xValue)
 *         for(i=0; i<ctr; i++){
 *           Gosub addrGosub
 *           AggStep (xInverse, iEphCsr)
 *           Next iEphCsr
 *         }
 *         Integer ctr 0
 *       }
 *       Incr ctr
 *     }
 *
 *     AggFinal (xFinalize)
 *     for(i=0; i<ctr; i++){
 *       Gosub addrGosub
 *       Next iEphCsr
 *     }
 *
 *     ResetSorter (csr)
 *     Return
 */
static void
windowCodeCacheStep(
	Parse *pParse,
	Select *p,
	WhereInfo *pWInfo,
	int regGosub,
	int addrGosub)
{
	Window *pMWin = p->pWin;
	Vdbe *v = sqlGetVdbe(pParse);
	int k;
	int addr;
	ExprList *pPart = pMWin->pPartition;
	ExprList *pOrderBy = pMWin->pOrderBy;
	int nPeer = pOrderBy ? pOrderBy->nExpr : 0;
	int regNewPeer;

	int addrGoto;		/* Address of Goto used to jump flush_par.. */
	int addrNext;		/* Jump here for next iteration of loop */
	int regFlushPart;
	int lblFlushPart;
	int csrLead;
	int regCtr;
	int regArg;		/* Register array to martial function args */
	int regSize;
	int lblEmpty;
	int bReverse = pMWin->pOrderBy && pMWin->eStart == TK_CURRENT &&
		       pMWin->eEnd == TK_UNBOUNDED;

	assert((pMWin->eStart == TK_UNBOUNDED && pMWin->eEnd == TK_CURRENT) ||
	       (pMWin->eStart == TK_UNBOUNDED && pMWin->eEnd == TK_UNBOUNDED) ||
	       (pMWin->eStart == TK_CURRENT && pMWin->eEnd == TK_CURRENT) ||
	       (pMWin->eStart == TK_CURRENT &&
		   pMWin->eEnd == TK_UNBOUNDED));

	lblEmpty = sqlVdbeMakeLabel(v);
	regNewPeer = pParse->nMem + 1;
	pParse->nMem += nPeer;

	/* Allocate register and label for the "flush_partition" sub-routine. */
	regFlushPart = ++pParse->nMem;
	lblFlushPart = sqlVdbeMakeLabel(v);

	csrLead = pParse->nTab++;
	regCtr = ++pParse->nMem;

	windowPartitionCache(pParse, p, pWInfo,
			     regFlushPart, lblFlushPart, &regSize);
	addrGoto = sqlVdbeAddOp0(v, OP_Goto);

	/* Start of "flush_partition" */
	sqlVdbeResolveLabel(v, lblFlushPart);
	sqlVdbeAddOp2(v, OP_Once, 0, sqlVdbeCurrentAddr(v) + 2);
	sqlVdbeAddOp3(v, OP_IteratorOpen, csrLead, 0, pMWin->regEph);
	sqlVdbeChangeP5(v, OPFLAG_EPH_DUP);

	/* Initialize the accumulator register for each window function to NULL */
	regArg = windowInitAccum(pParse, pMWin);

	sqlVdbeAddOp2(v, OP_Integer, 0, regCtr);
	sqlVdbeAddOp2(v, OP_Rewind, csrLead, lblEmpty);
	sqlVdbeAddOp2(v, OP_Rewind, pMWin->iEphCsr, lblEmpty);

	if (bReverse) {
		int addr = sqlVdbeCurrentAddr(v);
		windowAggStep(pParse, pMWin, csrLead, 0, regArg, regSize);
		sqlVdbeAddOp2(v, OP_Next, csrLead, addr);
		sqlVdbeAddOp2(v, OP_Rewind, csrLead, lblEmpty);
	}
	addrNext = sqlVdbeCurrentAddr(v);

	if (pOrderBy && (pMWin->eEnd == TK_CURRENT ||
			 pMWin->eStart == TK_CURRENT)) {
		int bCurrent = (pMWin->eStart == TK_CURRENT);
		int addrJump = 0;	/* Address of OP_Jump below */
		if (pMWin->eType == TK_RANGE) {
			int iOff = pMWin->nBufferCol + (pPart ?
							pPart->nExpr : 0);
			int regPeer = pMWin->regPart + (pPart ?
							pPart->nExpr : 0);
			struct sql_key_info *key_info;
			key_info = sql_expr_list_to_key_info(pParse,
							     pOrderBy, 0);
			for (k = 0; k < nPeer; k++) {
				sqlVdbeAddOp3(v, OP_Column, csrLead, iOff + k,
					      regNewPeer + k);
			}
			addr = sqlVdbeAddOp3(v, OP_Compare, regNewPeer,
					     regPeer, nPeer);
			sqlVdbeAppendP4(v, (void *)key_info, P4_KEYINFO);
			addrJump = sqlVdbeAddOp3(v, OP_Jump, addr + 2,
						 0, addr + 2);
			sqlVdbeAddOp3(v, OP_Copy, regNewPeer, regPeer,
				      nPeer - 1);
		}

		windowReturnRows(pParse, pMWin, regCtr, regGosub, addrGosub,
				 (bCurrent ? regArg : 0),
				 (bCurrent ? regSize : 0));
		if (addrJump)
			sqlVdbeJumpHere(v, addrJump);
	}

	if (bReverse == 0) {
		windowAggStep(pParse, pMWin, csrLead, 0, regArg, regSize);
	}
	sqlVdbeAddOp2(v, OP_AddImm, regCtr, 1);
	sqlVdbeAddOp2(v, OP_Next, csrLead, addrNext);

	windowReturnRows(pParse, pMWin, regCtr, regGosub, addrGosub, 0, 0);

	sqlVdbeResolveLabel(v, lblEmpty);
	sqlVdbeAddOp1(v, OP_ResetSorter, pMWin->iEphCsr);
	sqlVdbeAddOp1(v, OP_Return, regFlushPart);

	/* Jump to here to skip over flush_partition */
	sqlVdbeJumpHere(v, addrGoto);
}

/*
 * RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
 *
 *   ...
 *     if( new partition ){
 *       AggFinal (xFinalize)
 *       Gosub addrGosub
 *       ResetSorter eph-table
 *     }
 *     else if( new peer ){
 *       AggFinal (xValue)
 *       Gosub addrGosub
 *       ResetSorter eph-table
 *     }
 *     AggStep
 *     Insert (record into eph-table)
 *   sqlWhereEnd()
 *   AggFinal (xFinalize)
 *   Gosub addrGosub
 *
 * RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
 *
 *   As above, except take no action for a "new peer". Invoke
 *   the sub-routine once only for each partition.
 *
 * RANGE BETWEEN CURRENT ROW AND CURRENT ROW
 *
 *   As above, except that the "new peer" condition is handled in the
 *   same way as "new partition" (so there is no "else if" block).
 *
 * ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
 *
 *   As above, except assume every row is a "new peer".
 */
static void
windowCodeDefaultStep(
	Parse *pParse,
	Select *p,
	WhereInfo *pWInfo,
	int regGosub,
	int addrGosub)
{
	Window *pMWin = p->pWin;
	Vdbe *v = sqlGetVdbe(pParse);
	int k;
	int iSubCsr = p->pSrc->a[0].iCursor;
	int nSub = p->pSrc->a[0].space->def->field_count;
	int reg = pParse->nMem + 1;
	int regRowid = reg + nSub;
	int regRecord = regRowid + 1;
	int addr;
	ExprList *pPart = pMWin->pPartition;
	ExprList *pOrderBy = pMWin->pOrderBy;

	assert(pMWin->eType == TK_RANGE ||
	       (pMWin->eStart == TK_UNBOUNDED && pMWin->eEnd == TK_CURRENT));

	assert((pMWin->eStart == TK_UNBOUNDED && pMWin->eEnd == TK_CURRENT) ||
	       (pMWin->eStart == TK_UNBOUNDED && pMWin->eEnd == TK_UNBOUNDED) ||
	       (pMWin->eStart == TK_CURRENT && pMWin->eEnd == TK_CURRENT) ||
	       (pMWin->eStart == TK_CURRENT && pMWin->eEnd == TK_UNBOUNDED &&
	       !pOrderBy));

	if (pMWin->eEnd == TK_UNBOUNDED) {
		pOrderBy = 0;
	}

	pParse->nMem += nSub + 2;

	/*
	 * Martial the row returned by the sub-select into an array of
	 * registers.
	 */
	for (k = 0; k < nSub; k++) {
		sqlVdbeAddOp3(v, OP_Column, iSubCsr, k, reg + k);
	}

	/* Check if this is the start of a new partition or peer group. */
	if (pPart || pOrderBy) {
		int nPart = (pPart ? pPart->nExpr : 0);
		int addrGoto = 0;
		int addrJump = 0;
		int nPeer = (pOrderBy ? pOrderBy->nExpr : 0);

		if (pPart) {
			int regNewPart = reg + pMWin->nBufferCol;
			struct sql_key_info *key_info;
			key_info = sql_expr_list_to_key_info(pParse, pPart, 0);
			addr = sqlVdbeAddOp3(v, OP_Compare, regNewPart,
					     pMWin->regPart, nPart);
			sqlVdbeAppendP4(v, (void *)key_info, P4_KEYINFO);
			addrJump = sqlVdbeAddOp3(v, OP_Jump, addr + 2,
						 0, addr + 2);
			windowAggFinal(pParse, pMWin, 1);
			if (pOrderBy) {
				addrGoto = sqlVdbeAddOp0(v, OP_Goto);
			}
		}

		if (pOrderBy) {
			int regNewPeer = reg + pMWin->nBufferCol + nPart;
			int regPeer = pMWin->regPart + nPart;

			if (addrJump)
				sqlVdbeJumpHere(v, addrJump);
			if (pMWin->eType == TK_RANGE) {
				struct sql_key_info *key_info;
				key_info = sql_expr_list_to_key_info(pParse,
								     pOrderBy,
								     0);
				addr = sqlVdbeAddOp3(v, OP_Compare, regNewPeer,
						     regPeer, nPeer);
				sqlVdbeAppendP4(v, (void *)key_info,
						P4_KEYINFO);
				addrJump = sqlVdbeAddOp3(v, OP_Jump, addr + 2,
							 0, addr + 2);
			} else {
				addrJump = 0;
			}
			windowAggFinal(pParse, pMWin,
				       pMWin->eStart == TK_CURRENT);
			if (addrGoto)
				sqlVdbeJumpHere(v, addrGoto);
		}

		sqlVdbeAddOp2(v, OP_Rewind, pMWin->iEphCsr,
			      sqlVdbeCurrentAddr(v) + 3);
		sqlVdbeAddOp2(v, OP_Gosub, regGosub, addrGosub);
		sqlVdbeAddOp2(v, OP_Next, pMWin->iEphCsr,
			      sqlVdbeCurrentAddr(v) - 1);

		sqlVdbeAddOp1(v, OP_ResetSorter, pMWin->iEphCsr);
		sqlVdbeAddOp3(v, OP_Copy, reg + pMWin->nBufferCol,
			      pMWin->regPart, nPart + nPeer - 1);

		if (addrJump)
			sqlVdbeJumpHere(v, addrJump);
	}

	/* Invoke step function for window functions */
	windowAggStep(pParse, pMWin, -1, 0, reg, 0);

	/* Buffer the current row in the ephemeral table. */
	sqlVdbeAddOp2(v, OP_NextIdEphemeral, pMWin->regEph, regRowid);
	sqlVdbeAddOp3(v, OP_MakeRecord, reg, nSub + 1, regRecord);
	sqlVdbeChangeP5(v, 1);
	sqlVdbeAddOp2(v, OP_IdxInsert, regRecord, pMWin->regEph);

	/* End the database scan loop. */
	sqlWhereEnd(pWInfo);

	windowAggFinal(pParse, pMWin, 1);
	sqlVdbeAddOp2(v, OP_Rewind, pMWin->iEphCsr, sqlVdbeCurrentAddr(v) + 3);
	sqlVdbeAddOp2(v, OP_Gosub, regGosub, addrGosub);
	sqlVdbeAddOp2(v, OP_Next, pMWin->iEphCsr, sqlVdbeCurrentAddr(v) - 1);
}

/*
 * Allocate and return a duplicate of the Window object indicated by the
 * third argument. Set the Window.pOwner field of the new object to
 * pOwner.
 */
Window *
sqlWindowDup(Expr *pOwner, Window *p)
{
	Window *pNew = 0;
	if (ALWAYS(p)) {
		pNew = sql_xmalloc0(sizeof(Window));
		pNew->zName = sql_xstrdup(p->zName);
		pNew->pFilter = sqlExprDup(p->pFilter, 0);
		pNew->pFunc = p->pFunc;
		pNew->pPartition = sql_expr_list_dup(p->pPartition, 0);
		pNew->pOrderBy = sql_expr_list_dup(p->pOrderBy, 0);
		pNew->eType = p->eType;
		pNew->eEnd = p->eEnd;
		pNew->eStart = p->eStart;
		pNew->pStart = sqlExprDup(p->pStart, 0);
		pNew->pEnd = sqlExprDup(p->pEnd, 0);
		pNew->pOwner = pOwner;
	}
	return pNew;
}

/*
 * Return a copy of the linked list of Window objects passed as the
 * second argument.
 */
Window *
sqlWindowListDup(Window *p)
{
	Window *pWin;
	Window *pRet = 0;
	Window **pp = &pRet;

	for (pWin = p; pWin; pWin = pWin->pNextWin) {
		*pp = sqlWindowDup(0, pWin);
		if (*pp == 0)
			break;
		pp = &((*pp)->pNextWin);
	}

	return pRet;
}

/*
 * sqlWhereBegin() has already been called for the SELECT statement
 * passed as the second argument when this function is invoked. It generates
 * code to populate the Window.regResult register for each window function and
 * invoke the sub-routine at instruction addrGosub once for each row.
 * This function calls sqlWhereEnd() before returning.
 */
void
sqlWindowCodeStep(
	Parse *pParse,		/* Parse context */
	Select *p,		/* Rewritten SELECT statement */
	WhereInfo *pWInfo,	/* Context returned by sqlWhereBegin() */
	int regGosub,		/* Register for OP_Gosub */
	int addrGosub)		/* OP_Gosub here to return each row */
{
	Window *pMWin = p->pWin;

	/* There are three different functions that may be used to do the work
	 * of this one, depending on the window frame and the specific built-in
	 * window functions used (if any).
	 *
	 * windowCodeRowExprStep() handles all "ROWS" window frames, except for:
	 *
	 *	 ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
	 *
	 * The exception is because windowCodeRowExprStep() implements all
	 * window frame types by caching the entire partition in a temp table,
	 * and "ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW" is easy enough
	 * to implement without such a cache.
	 *
	 * windowCodeCacheStep() is used for:
	 *
	 *	 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING
	 *
	 * It is also used for anything not handled by windowCodeRowExprStep()
	 * that invokes a built-in window function that requires the entire
	 * partition to be cached in a temp table before any rows are returned
	 * (e.g. nth_value() or percent_rank()).
	 *
	 * Finally, assuming there is no built-in window function that requires
	 * the partition to be cached, windowCodeDefaultStep() is used for:
	 *
	 *	 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
	 *	 RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
	 *	 RANGE BETWEEN CURRENT ROW AND CURRENT ROW
	 *	 ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
	 *
	 * windowCodeDefaultStep() is the only one of the three functions that
	 * does not cache each partition in a temp table before beginning to
	 * return rows.
	 */
	if (pMWin->eType == TK_ROWS &&
	    (pMWin->eStart != TK_UNBOUNDED ||
	    pMWin->eEnd != TK_CURRENT ||
	    !pMWin->pOrderBy)) {
		windowCodeRowExprStep(pParse, p, pWInfo,
				      regGosub, addrGosub);
	} else {
		/* True to use CacheStep() */
		int bCache = 0;

		if (pMWin->eStart == TK_CURRENT &&
		    pMWin->eEnd == TK_UNBOUNDED) {
			bCache = 1;
		}

		/* Otherwise, call windowCodeDefaultStep().	*/
		if (bCache) {
			windowCodeCacheStep(pParse, p, pWInfo,
					    regGosub, addrGosub);
		} else {
			windowCodeDefaultStep(pParse, p, pWInfo,
					      regGosub, addrGosub);
		}
	}
}
